"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[5040],{3905:(e,t,i)=>{i.d(t,{Zo:()=>u,kt:()=>g});var n=i(67294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(i),d=a,g=m["".concat(s,".").concat(d)]||m[d]||p[d]||o;return i?n.createElement(g,r(r({ref:t},u),{},{components:i})):n.createElement(g,r({ref:t},u))}));function g(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=i.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=i[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}d.displayName="MDXCreateElement"},35516:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=i(87462),a=(i(67294),i(3905));const o={title:"Configuration versioning",authors:"lbarczio"},r=void 0,l={unversionedId:"ux/configuration-versioning",id:"ux/configuration-versioning",title:"Configuration versioning",description:"Example use cases we would like to solve with this:",source:"@site/research/ux/configuration-versioning.md",sourceDirName:"ux",slug:"/ux/configuration-versioning",permalink:"/research/ux/configuration-versioning",draft:!1,editUrl:"https://github.com/packit/research/tree/main/research/ux/configuration-versioning.md",tags:[],version:"current",frontMatter:{title:"Configuration versioning",authors:"lbarczio"},sidebar:"autogenerated",previous:{title:"Automatic Configuration Updates",permalink:"/research/ux/automatic-config-updates"},next:{title:"Improve Packit Service event processing",permalink:"/research/ux/improve-service-processing"}},s={},c=[{value:"Existing support",id:"existing-support",level:2},{value:"Versioning jobs aside from the whole config",id:"versioning-jobs-aside-from-the-whole-config",level:2},{value:"Implementation details for the whole config versioning",id:"implementation-details-for-the-whole-config-versioning",level:2},{value:"Versioning",id:"versioning",level:3},{value:"How this could work",id:"how-this-could-work",level:3},{value:"Plan",id:"plan",level:2}],u={toc:c},m="wrapper";function p(e){let{components:t,...i}=e;return(0,a.kt)(m,(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Example use cases we would like to solve with this:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Example 1: Image builder job - it will probably evolve over time depending on the requirements"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/packit/packit.dev/issues/443"},"Example 2"),": Changing interpretation of job overrides from replacing the values to merging")),(0,a.kt)("h2",{id:"existing-support"},"Existing support"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"no support from Marshmallow, ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/marshmallow-code/marshmallow/issues/1107"},"see")),(0,a.kt)("li",{parentName:"ul"},"in general, I have not found any existing support to do this"),(0,a.kt)("li",{parentName:"ul"},"some tips from the issue above:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"utilising ",(0,a.kt)("inlineCode",{parentName:"li"},"render_module")," (from ",(0,a.kt)("a",{parentName:"li",href:"https://marshmallow.readthedocs.io/en/3.0/api_reference.html#marshmallow.Schema.Meta"},"this class"),") - a class that defines loads and dumps, which defaults to json,\ncould be a good place to intercept the raw data on a per-schema basis"),(0,a.kt)("li",{parentName:"ul"},"migrating the raw data before deserializing to avoid maintaining a schema history")))),(0,a.kt)("h2",{id:"versioning-jobs-aside-from-the-whole-config"},"Versioning jobs aside from the whole config"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"this would be mostly beneficial for versioning only one job type (e.g. vm_image_build)"),(0,a.kt)("li",{parentName:"ul"},"since all the job-related fields in the job config are grouped in a class together, this would not be straightforward"),(0,a.kt)("li",{parentName:"ul"},"we could have specific fields that would be versioned and have own schema\ne.g. in case of Image builder job having some field that would introduce a nested schema\nand we could have different versions of these: e.g.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'- job: vm_image_build\n    trigger: pull_request\n    image_builder_metadata:\n      version: 1\n      image_request:\n        packages_to_install: [packit]\n        owner: packit\n        project: packit-dev\n      image_customizations:\n        image_type: aws\n        image_architecture: x86_64\n        image_account_id: "727920394381"\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'- job: vm_image_build\n    trigger: pull_request\n    image_builder_metadata:\n      version: 2\n      image_distribution: rhel-8\n      image_type: aws\n      image_architecture: x86_64\n      image_account_id: "727920394381"\n      packages_to_install: [packit]\n      owner: packit\n      project: packit-dev\n')),(0,a.kt)("p",null,"and schemas:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class ImageBuilderMetadataV1(ImageBuilderMetadataSchema):\n    image_distribution = fields.String(missing=None)\n    image_request = fields.Dict(missing=None)\n    image_customizations = fields.Dict(missing=None)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class ImageBuilderMetadataV2(ImageBuilderMetadataSchema):\n    image_distribution = fields.String(missing=None)\n    image_type: fields.String(missing=None)\n    image_architecture = fields.String(missing=None)\n    image_account_id = fields.String(missing=None)\n    packages_to_install = fields.String(missing=None)\n    owner = fields.String(missing=None)\n    project = fields.String(missing=None)\n")),(0,a.kt)("p",null,"and the config object would have all the fields and the code could handle both"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"from the coding perspective this would not be a problem - the version would be detected either from whole config\nor directly from the ",(0,a.kt)("inlineCode",{parentName:"li"},"image_builder_metadata")),(0,a.kt)("li",{parentName:"ul"},"but this may be confusing to users - versioning some configuration field apart from the whole config,",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"if we would do both whole config versioning and only fields versioning, this would become\ncomplicated and we would need to solve integration of both")))),(0,a.kt)("h2",{id:"implementation-details-for-the-whole-config-versioning"},"Implementation details for the whole config versioning"),(0,a.kt)("h3",{id:"versioning"},"Versioning"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"for each backwards incompatible change, we would bump the version"),(0,a.kt)("li",{parentName:"ul"},"there would be a default version, options:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},'1 - since 1 would be the version "before starting the versioning", it would be the most\nnatural that if there is no version specified, the version is 1 (Docker does the same)'),(0,a.kt)("li",{parentName:"ul"},"always the latest: we would need to enforce with introducing the first backwards incompatible change\nthat all projects have the version set in their configs to 1 or use the changed schema (we could\nopen PRs to projects with the config change, ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/packit/research/issues/159"},"see"),")"))),(0,a.kt)("li",{parentName:"ul"},"this would be properly documented, we can get inspired by Docker,\n",(0,a.kt)("a",{parentName:"li",href:"https://docs.docker.com/compose/compose-file/compose-versioning/#versioning"},"see"),", the documentation\nwould also include Packit version that starts supporting the particular configuration schema")),(0,a.kt)("h3",{id:"how-this-could-work"},"How this could work"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"check the version in ",(0,a.kt)("inlineCode",{parentName:"li"},"PackageConfig.get_from_dict()")," (use the default if not present)"),(0,a.kt)("li",{parentName:"ul"},"import the schema classes matching that version:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'if version == "1":\n    from packit.schema.v1 import PackageConfigSchema\nelif version == "2":\n    from packit.schema.v2 import PackageConfigSchema\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"this would allow partially redefining schema classes or reexporting existing schema classes, e.g. in ",(0,a.kt)("inlineCode",{parentName:"li"},"packit.schema.v2"),":")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from packit.schema.v1 import PackageConfigSchema as PackageConfigSchemaV1\n# reexport as v2, without a change\nfrom packit.schema.v1 import JobConfig\n\nclass PackageConfigSchema(PackageConfigSchemaV1):\n    # override some fields\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"we would need to make sure that load-dump-load results in same representation"),(0,a.kt)("li",{parentName:"ul"},"config classes would not be versioned - all config schema versions need to be migrated when loading\nthe configuration to the latest state of the configuration object")),(0,a.kt)("h2",{id:"plan"},"Plan"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"consider also relation to ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/packit/research/issues/159"},"this issue"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"if we would introduce some change that would break the compatibility, we would open PRs for each repository that\nuses the particular configuration field"),(0,a.kt)("li",{parentName:"ul"},"this could not be sufficient for all use cases"))),(0,a.kt)("li",{parentName:"ul"},"decide whether we want to support versioning of only some fields"),(0,a.kt)("li",{parentName:"ul"},"decide what would be the default if version not specified in the config (and plan\nif we want to open PRs to existing projects with introducing ",(0,a.kt)("inlineCode",{parentName:"li"},"version")," field and providing link to\nexplaining documentation)"),(0,a.kt)("li",{parentName:"ul"},"with the next introduction of backwards incompatible change/ or right away, start versioning the schema")))}p.isMDXComponent=!0}}]);