"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[17547],{15680:(e,a,t)=>{t.d(a,{xA:()=>g,yg:()=>d});var n=t(96540);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=n.createContext({}),p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},g=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),c=p(t),u=i,d=c["".concat(s,".").concat(u)]||c[u]||m[u]||o;return t?n.createElement(d,r(r({ref:a},g),{},{components:t})):n.createElement(d,r({ref:a},g))}));function d(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=u;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},50290:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=t(58168),i=(t(96540),t(15680));const o={title:"Global configuration",authors:["mmassari"],sidebar_position:1},r=void 0,l={unversionedId:"global-config/index",id:"global-config/index",title:"Global configuration",description:"You can customize the service configuration for a user project in two different ways:",source:"@site/research/global-config/index.md",sourceDirName:"global-config",slug:"/global-config/",permalink:"/research/global-config/",draft:!1,editUrl:"https://github.com/packit/research/tree/main/research/global-config/index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Global configuration",authors:["mmassari"],sidebar_position:1},sidebar:"autogenerated",previous:{title:"Research notes",permalink:"/research/"},next:{title:"Job referencing",permalink:"/research/job_referencing/"}},s={},p=[{value:"Advantages",id:"advantages",level:2},{value:"Disadvantages",id:"disadvantages",level:2},{value:"Advantages",id:"advantages-1",level:2},{value:"Disadvantages",id:"disadvantages-1",level:2},{value:"Configuration Layers",id:"configuration-layers",level:2},{value:"Service-Side Layer",id:"service-side-layer",level:3},{value:"User-Side Layer",id:"user-side-layer",level:3},{value:"Configurations chain implementation",id:"configurations-chain-implementation",level:2},{value:"1. Templating",id:"1-templating",level:3},{value:"https://github.com/packit/templeates/config/simple-pull-from-upstream.yaml.j2",id:"httpsgithubcompackittempleatesconfigsimple-pull-from-upstreamyamlj2",level:4},{value:"https://gitlab.gnome.org/packit/templates/configs/gnome-tests.yaml.j2",id:"httpsgitlabgnomeorgpackittemplatesconfigsgnome-testsyamlj2",level:4},{value:"https://gitlab.gnome.org/package/packit.yaml",id:"httpsgitlabgnomeorgpackagepackityaml",level:4},{value:"2. Global config + overlay",id:"2-global-config--overlay",level:3},{value:"https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml.j2",id:"httpsgithubcompackittemplatesconfigsstandard-pull-from-upstreamyamlj2",level:4},{value:"https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml.j2",id:"httpsgitlabgnomeorgpackittemplatesconfigsdefault_packityamlj2",level:4},{value:"https://gitlab.gnome.org/package/packit.yaml",id:"httpsgitlabgnomeorgpackagepackityaml-1",level:4},{value:"3. Inheritance",id:"3-inheritance",level:3},{value:"https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml",id:"httpsgithubcompackittemplatesconfigsstandard-pull-from-upstreamyaml",level:4},{value:"https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml",id:"httpsgitlabgnomeorgpackittemplatesconfigsdefault_packityaml",level:4},{value:"https://gitlab.gnome.org/package/packit.yaml",id:"httpsgitlabgnomeorgpackagepackityaml-2",level:4},{value:"PROs and CONs",id:"pros-and-cons",level:3},{value:"Templating",id:"templating",level:4},{value:"Pros",id:"pros",level:5},{value:"Cons",id:"cons",level:5},{value:"Global config + overlays",id:"global-config--overlays",level:4},{value:"Pros",id:"pros-1",level:5},{value:"Cons",id:"cons-1",level:5},{value:"Inheritance",id:"inheritance",level:4},{value:"Pros",id:"pros-2",level:5},{value:"Cons",id:"cons-2",level:5},{value:"Implementation",id:"implementation",level:3},{value:"Jinja2 vs Ansible library",id:"jinja2-vs-ansible-library",level:4},{value:"Performances",id:"performances",level:3},{value:"packit-service defaults",id:"packit-service-defaults",level:3},{value:"<code>python-noggin-messages</code> and <code>libmodulemd</code> projects configurations",id:"python-noggin-messages-and-libmodulemd-projects-configurations",level:2},{value:"<code>python-noggin-messages</code>",id:"python-noggin-messages",level:3},{value:"<code>libmodulemd</code>",id:"libmodulemd",level:3},{value:"The problems",id:"the-problems",level:3},{value:"Possible solutions",id:"possible-solutions",level:3}],g={toc:p},c="wrapper";function m(e){let{components:a,...t}=e;return(0,i.yg)(c,(0,n.A)({},g,t,{components:a,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"You can customize the service configuration for a user project in two different ways:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"There is a configuration on the service side which has to be updated by the service team (upon notification from the service users for opt-in or opt-out from the service). This is how you can enable or disable Zuul for the Fedora CI nowadays.\nI will refer to this solution as a ",(0,i.yg)("strong",{parentName:"li"},"top-down solution"),"."),(0,i.yg)("li",{parentName:"ol"},"There is a configuration, related with the service, on the user's project side. This is how packit works today. I will refer to this solution as a ",(0,i.yg)("strong",{parentName:"li"},"bottom-up solution"),".")),(0,i.yg)("p",null,"You can configure services for individual projects in two ways:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Top-Down solution: configuration resides on the service side, managed by the service team. Users notify the team to opt in or out. Example: Zuul for Fedora CI uses this approach (",(0,i.yg)("a",{parentName:"p",href:"https://pagure.io/fedora-project-config/blob/master/f/resources/fedora-distgits.yaml"},"configuration reference"),").")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Bottom-Up solution: configuration lives in the user's project repository. Packit currently implements this approach."))),(0,i.yg)("p",null,"The top-down approach represents a global configuration, while the bottom-up solution can reference global or semi-global configurations. Let's analyze both approaches."),(0,i.yg)("h1",{id:"top-down-solution"},"Top-Down solution"),(0,i.yg)("p",null,"The service side maintains project-specific behavior configurations."),(0,i.yg)("h2",{id:"advantages"},"Advantages"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Users don't need configuration files in their projects; they might not like the idea of having a service related file in their projects."),(0,i.yg)("li",{parentName:"ul"},"Configuration migrations are straightforward for the service team; it is just a change in a file that belongs to the team."),(0,i.yg)("li",{parentName:"ul"},"Highest performance due to direct configuration access; no need to load and pre-process other files."),(0,i.yg)("li",{parentName:"ul"},"Quickest implementation; this approach is the same as for the packit-service configuration file.")),(0,i.yg)("h2",{id:"disadvantages"},"Disadvantages"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"It is probably easier, for the final user, to look for the service configuration file in its own repo instead of a service repo."),(0,i.yg)("li",{parentName:"ul"},"Less user engagement due to limited visibility of configuration changes. Even though a configuration migration can be simpler for the service team it could be less explicit for the final user. Being able to change behaviour without the user acknowledging it could not be a good idea. In packit there already is a configuration migration script."),(0,i.yg)("li",{parentName:"ul"},"The global configuration file could really grow huge and be difficult to maintain both for the service team and for a final user that wants to contribute to it."),(0,i.yg)("li",{parentName:"ul"},'Lacks ecosystem-specific configuration management. There is no encapsulation for "middle layer" knowledge, no easy way to manage ecosystem configurations. Configurations could be grouped in different nodes with different defaults but there is no easy way, for the service team, to know if the user who is asking to update a configuration has the rights for doing so.'),(0,i.yg)("li",{parentName:"ul"},"Differs from Packit's current approach, potentially confusing users. This could work mainly for the ",(0,i.yg)("em",{parentName:"li"},"Fedora CI")," and could confuse users that use the standard packit configuration for ",(0,i.yg)("em",{parentName:"li"},"upstream continuous integration")," and ",(0,i.yg)("em",{parentName:"li"},"release synchronization"),".")),(0,i.yg)("h1",{id:"bottom-up-solution"},"Bottom-Up solution"),(0,i.yg)("p",null,"Project-side configuration with ability to reference global configurations."),(0,i.yg)("h2",{id:"advantages-1"},"Advantages"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"User-friendly and explicit. Everything is on the user side (more quick for him) and the file will never grow too much because of other project details."),(0,i.yg)("li",{parentName:"ul"},"Flexible customization through layered configurations and better ecosystem-specific configuration support."),(0,i.yg)("li",{parentName:"ul"},"Consistent with current Packit implementation.")),(0,i.yg)("h2",{id:"disadvantages-1"},"Disadvantages"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"More complex configuration migrations because they are on the user side."),(0,i.yg)("li",{parentName:"ul"},"Additional processing overhead. It will require time to load multiple configuration layers."),(0,i.yg)("li",{parentName:"ul"},"Requires implementation of inheritance/templating mechanisms.")),(0,i.yg)("h2",{id:"configuration-layers"},"Configuration Layers"),(0,i.yg)("h3",{id:"service-side-layer"},"Service-Side Layer"),(0,i.yg)("p",null,"The last layer of a configuration chain could be on the service side and it could be referenced in a sort of opt-in mechanism or it could be automatically applied."),(0,i.yg)("h3",{id:"user-side-layer"},"User-Side Layer"),(0,i.yg)("p",null,"At the moment the packit service needs just one configuration file on the user project side both for the ",(0,i.yg)("strong",{parentName:"p"},"upstream continuous integration")," and for the ",(0,i.yg)("strong",{parentName:"p"},"release synchronization"),".\nWhen implementing the ",(0,i.yg)("strong",{parentName:"p"},"Fedora CI")," (which is a ",(0,i.yg)("em",{parentName:"p"},"downstream continuous integration"),") a new configuration file could be required or the configuration can be merged with the existing one."),(0,i.yg)("h2",{id:"configurations-chain-implementation"},"Configurations chain implementation"),(0,i.yg)("p",null,"There could be different ways for managing configuration relationships, I will analyse three of them:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"templating"),(0,i.yg)("li",{parentName:"ul"},"global configuration + overlays"),(0,i.yg)("li",{parentName:"ul"},"inheritance")),(0,i.yg)("h3",{id:"1-templating"},"1. Templating"),(0,i.yg)("h4",{id:"httpsgithubcompackittempleatesconfigsimple-pull-from-upstreamyamlj2"},(0,i.yg)("a",{parentName:"h4",href:"https://github.com/packit/templeates/config/simple-pull-from-upstream.yaml.j2"},"https://github.com/packit/templeates/config/simple-pull-from-upstream.yaml.j2")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},'# Packit pull-from-upstream config\nspecfile_path: { { specfile_path } }\n\nupstream_package_name: { { upstream_package_name } }\ndownstream_package_name: { { downstream_package_name } }\nupstream_project_url: { { upstream_package_url } }\nupstream_tag_template: v{version}\n\njobs:\n  - job: pull_from_upstream\n    trigger: release\n    dist_git_branches:\n      - fedora-rawhide\n  - job: koji_build\n    trigger: commit\n    allowed_pr_authors: ["packit", { { allowed_pr_authors } }]\n    dist_git_branches:\n      - fedora-rawhide\n')),(0,i.yg)("h4",{id:"httpsgitlabgnomeorgpackittemplatesconfigsgnome-testsyamlj2"},(0,i.yg)("a",{parentName:"h4",href:"https://gitlab.gnome.org/packit/templates/configs/gnome-tests.yaml.j2"},"https://gitlab.gnome.org/packit/templates/configs/gnome-tests.yaml.j2")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},'# Gnome default tests config\njobs:\n  - job: tests\n    trigger: pull_request\n    packages: [{{ downstream_package_name }}]\n    tmt_plan: "smoke|full|packit-integration|{{ tmt_other_plans }}"\n    targets:\n      - fedora-rawhide\n  {% if tests_on_commit %}\n  - job: tests\n    trigger: commit\n    packages: [{{ downstream_package_name }}]\n    tmt_plan: "smoke|full|packit-integration|{{ tmt_other_plans }}"\n    targets:\n      - fedora-rawhide\n  {% endif %}\n')),(0,i.yg)("h4",{id:"httpsgitlabgnomeorgpackagepackityaml"},(0,i.yg)("a",{parentName:"h4",href:"https://gitlab.gnome.org/package/packit.yaml"},"https://gitlab.gnome.org/package/packit.yaml")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},"# A gnome package packit config\ntemplates:\n  - https://github.com/packit/templeates/config/simple-pull-from-upstream.yaml.j2\n    vars:\n      specfile_path: specfile_path\n      upstream_package_name: upstream_package_name\n      downstream_package_name: downstream_package_name\n      upstream_project_url: upstream_project_url\n      allowed_pr_authors: allowed_pr_authors\n  - https://gitlab.gnome.org/packit/templates/configs/gnome-tests.yaml.j2\n      downstream_package_name: downstream_package_name\n      tmt_other_plans: tmt_other_plans\n      tests_on_commit: false\n")),(0,i.yg)("h3",{id:"2-global-config--overlay"},"2. Global config + overlay"),(0,i.yg)("h4",{id:"httpsgithubcompackittemplatesconfigsstandard-pull-from-upstreamyamlj2"},(0,i.yg)("a",{parentName:"h4",href:"https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml.j2"},"https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml.j2")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},'# Packit pull-from-upstream config\nspecfile_path: { { specfile_path } }\n\nupstream_package_name: { { upstream_package_name } }\ndownstream_package_name: { { downstream_package_name } }\nupstream_project_url: { { upstream_package_url } }\nupstream_tag_template: v{version}\n\njobs:\n  - job: pull_from_upstream\n    trigger: release\n    dist_git_branches:\n      - fedora-rawhide\n  - job: koji_build\n    trigger: commit\n    allowed_pr_authors: ["packit", { { allowed_pr_authors } }]\n    dist_git_branches:\n      - fedora-rawhide\n')),(0,i.yg)("h4",{id:"httpsgitlabgnomeorgpackittemplatesconfigsdefault_packityamlj2"},(0,i.yg)("a",{parentName:"h4",href:"https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml.j2"},"https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml.j2")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},'# Gnome default packit config\nconfig:\n  base: https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml.j2\n  values:\n    allowed_pr_authors: gnome-admins\n\njobs:\n  - job: tests\n    trigger: pull_request\n    packages: [{{ downstream_package_name }}]\n    tmt_plan: "smoke|full|packit-integration|{{ tmt_other_plans }}"\n    targets:\n      - fedora-rawhide\n  {% if tests_on_commit %}\n  - job: tests\n    trigger: commit\n    packages: [{{ downstream_package_name }}]\n    tmt_plan: "smoke|full|packit-integration|{{ tmt_other_plans }}"\n    targets:\n      - fedora-rawhide\n  {% endif %}\n')),(0,i.yg)("h4",{id:"httpsgitlabgnomeorgpackagepackityaml-1"},(0,i.yg)("a",{parentName:"h4",href:"https://gitlab.gnome.org/package/packit.yaml"},"https://gitlab.gnome.org/package/packit.yaml")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},"# A gnome package packit config\nconfig:\n  base: https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml.j2\n  values:\n    specfile_path: specfile_path\n    upstream_package_name: upstream_package_name\n    downstream_package_name: downstream_package_name\n    upstream_project_url: upstream_package_url\n    tmt_other_plans: package-tests\n    tests_on_commit: false\n")),(0,i.yg)("h3",{id:"3-inheritance"},"3. Inheritance"),(0,i.yg)("h4",{id:"httpsgithubcompackittemplatesconfigsstandard-pull-from-upstreamyaml"},(0,i.yg)("a",{parentName:"h4",href:"https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml"},"https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},'# Packit pull-from-upstream config\nspecfile_path: -OVERRIDE ME-\n\nupstream_package_name: -OVERRIDE ME-\ndownstream_package_name: -OVERRIDE ME-\nupstream_project_url: -OVERRIDE ME-\n\nupstream_tag_template: v{version}\n\njobs:\n  - job: pull_from_upstream\n    trigger: release\n    dist_git_branches:\n      - fedora-rawhide\n  - job: koji_build\n    trigger: commit\n    allowed_pr_authors: ["packit"]\n    dist_git_branches:\n      - fedora-rawhide\n')),(0,i.yg)("h4",{id:"httpsgitlabgnomeorgpackittemplatesconfigsdefault_packityaml"},(0,i.yg)("a",{parentName:"h4",href:"https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml"},"https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},'# Gnome default packit config\ninherit: https://github.com/packit/templates/configs/standard-pull-from-upstream.yaml\n\njobs:\n  - job: koji_build\n    allowed_pr_authors: ["packit", "gnome-admins"]\n\n  - job: tests\n    trigger: pull_request\n    tmt_plan: "smoke|full|packit-integration"\n    targets:\n      - fedora-rawhide\n')),(0,i.yg)("h4",{id:"httpsgitlabgnomeorgpackagepackityaml-2"},(0,i.yg)("a",{parentName:"h4",href:"https://gitlab.gnome.org/package/packit.yaml"},"https://gitlab.gnome.org/package/packit.yaml")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},'# A gnome package packit config\ninherit: https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml\n\nspecfile_path: specfile_path\nupstream_package_name: upstream_package_name\ndownstream_package_name: downstream_package_name\nupstream_project_url: upstream_package_url\n\njobs:\n  - job: tests\n    packages: ["downstream_package_name"]\n    tmt_plan: "smoke|full|packit-integration|package-tests"\n')),(0,i.yg)("h3",{id:"pros-and-cons"},"PROs and CONs"),(0,i.yg)("h4",{id:"templating"},"Templating"),(0,i.yg)("h5",{id:"pros"},"Pros"),(0,i.yg)("p",null,"Flexible, probably the most flexible implementation that allows to freely mix configuration snippets for creating a customized final configuration."),(0,i.yg)("h5",{id:"cons"},"Cons"),(0,i.yg)("p",null,'The "pure" templating mechanism, in the above example, requires the package maintainer to know that koji builds, in the gnome ecosystem, should be allowed for any ',(0,i.yg)("strong",{parentName:"p"},"gnome-admin"),", instead ",(0,i.yg)("em",{parentName:"p"},"inheritance")," and ",(0,i.yg)("em",{parentName:"p"},"global config + overlays")," encapsulate well the knowledge in the middle layer packit config."),(0,i.yg)("p",null,"Templating is flexible but on the other end it is more error prone; there is no ",(0,i.yg)("em",{parentName:"p"},"base configuration")," and a packager can list templates in the wrong order."),(0,i.yg)("p",null,"Probably, in the end, the packager will use smaller config snippets, decreasing performance and readability."),(0,i.yg)("h4",{id:"global-config--overlays"},"Global config + overlays"),(0,i.yg)("h5",{id:"pros-1"},"Pros"),(0,i.yg)("p",null,"Good knowledge encapsulation in middle layers (see the ",(0,i.yg)("strong",{parentName:"p"},"gnome-admin")," for allowed_pr_authors in the above example)."),(0,i.yg)("p",null,"Explicit and thus easily readable, since the use of templating."),(0,i.yg)("p",null,"Flexible, config snippets can easily be removed using template conditional functionalities (as in the above example for the test job with trigger commit)."),(0,i.yg)("h5",{id:"cons-1"},"Cons"),(0,i.yg)("p",null,"The templating syntax can be more error prone if compared with inheritance."),(0,i.yg)("h4",{id:"inheritance"},"Inheritance"),(0,i.yg)("h5",{id:"pros-2"},"Pros"),(0,i.yg)("p",null,"Concise, it's the most concise syntax we could use and probably the least error prone."),(0,i.yg)("h5",{id:"cons-2"},"Cons"),(0,i.yg)("p",null,"Poor flexibility, I don't see an easy way to disable the above test job with trigger commit."),(0,i.yg)("p",null,"Not really explicit, even though we use a placeholder it is harder to recognize the keys that need overriding."),(0,i.yg)("h3",{id:"implementation"},"Implementation"),(0,i.yg)("p",null,"Personally I find the ",(0,i.yg)("em",{parentName:"p"},"global config + overlays")," approach the best and in this case we would need to:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"add the following keys to the ",(0,i.yg)("inlineCode",{parentName:"li"},"PackageConfig")," class:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yml"},"config:\n  base: https://gitlab.gnome.org/packit/templates/configs/default_packit.yaml.j2\n  values: ...\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"load the packit.yaml file and search for the ",(0,i.yg)("inlineCode",{parentName:"p"},"config")," key in it. If a ",(0,i.yg)("inlineCode",{parentName:"p"},"config")," key is found we need to ",(0,i.yg)("strong",{parentName:"p"},"recursively")," look for the ",(0,i.yg)("em",{parentName:"p"},"base config")," and start processing all the templates in the chain, creating a new temporary packit.yml that will be used instead of the original one.\nI see this code tied with the ",(0,i.yg)("inlineCode",{parentName:"p"},"LocalProject")," class but I can be wrong.\nWe should make the new code work both for the packit CLI and the packit-service. Thinking at packit CLI, we should probably stay flexible and let the ",(0,i.yg)("inlineCode",{parentName:"p"},"base: URI")," be also a local url (like ",(0,i.yg)("inlineCode",{parentName:"p"},"file:///"),").")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"let the user know what the final configuration looks like (both for CLI and service)."))),(0,i.yg)("h4",{id:"jinja2-vs-ansible-library"},"Jinja2 vs Ansible library"),(0,i.yg)("p",null,"For template management I would probably just use the ",(0,i.yg)("strong",{parentName:"p"},"jinja2 template library"),", even though we can also think about the ansible library.\nThe ansible library could let us use ",(0,i.yg)("inlineCode",{parentName:"p"},"built-in filters and functions")," but I don't see use cases for them and as a cons it has a heavier dependency footprint."),(0,i.yg)("h3",{id:"performances"},"Performances"),(0,i.yg)("p",null,"Splitting the configuration in multiple configuration files will lead obviously to worst performance. Personally I don't see a way to prevent it."),(0,i.yg)("p",null,"We can limit the number of recursion steps; 3/4 steps are, from my point of view, more than enough. Having a recursion limit will avoid an infinite recursion for malformed configurations."),(0,i.yg)("h3",{id:"packit-service-defaults"},"packit-service defaults"),(0,i.yg)("p",null,'It could happen that the packit-service config defaults for the "Fedora CI instance" and those for the "Usual instance" (as an example) diverge.'),(0,i.yg)("p",null,"If it happens we could create two ",(0,i.yg)("em",{parentName:"p"},"hidden"),", ",(0,i.yg)("em",{parentName:"p"},"inner")," packit config bases, one per instance, which will always be used for merging any packit config we process; in this way the differences will be grouped explicitly in a single place and we could, probably, enable and disable jobs for one instance or the other (as an example ",(0,i.yg)("inlineCode",{parentName:"p"},"pull-from-upstream")," should not appear in fedora ci packit configuration) just using templating."),(0,i.yg)("h1",{id:"packit-100-release---package-config-related-notes"},"Packit 1.0.0 release - package config related notes"),(0,i.yg)("p",null,'Releasing packit 1.0.0 has been useful to realize we already struggle with handling multiple packit configurations "per project" (even though it is not easy to say what a "project" is...).'),(0,i.yg)("p",null,"I write my findings down because I think the solution we choose should help us handle these corner cases better next time."),(0,i.yg)("h2",{id:"python-noggin-messages-and-libmodulemd-projects-configurations"},(0,i.yg)("inlineCode",{parentName:"h2"},"python-noggin-messages")," and ",(0,i.yg)("inlineCode",{parentName:"h2"},"libmodulemd")," projects configurations"),(0,i.yg)("h3",{id:"python-noggin-messages"},(0,i.yg)("inlineCode",{parentName:"h3"},"python-noggin-messages")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"configuration-migrations")," script had generated a ",(0,i.yg)("a",{parentName:"li",href:"https://github.com/fedora-infra/noggin-messages/pull/400/files"},"PR to update the upstream configuration")," and the team merged it."),(0,i.yg)("li",{parentName:"ul"},"However, the downstream configuration remained inconsistent and was throwing errors in packit service, thus I ",(0,i.yg)("a",{parentName:"li",href:"https://src.fedoraproject.org/rpms/python-noggin-messages/pull-request/9"},"created a PR manually"))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},"[...]\nfiles_to_sync:\n    - python-noggin-messages.spec\n    - 0001-Revert-Include-additional-files-in-the-sdist.patch\n    - README.md\n    - sources\n    - .packit.yaml\n[...]\n  - job: sync_from_downstream\n    trigger: commit\n")),(0,i.yg)("h3",{id:"libmodulemd"},(0,i.yg)("inlineCode",{parentName:"h3"},"libmodulemd")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"configuration-migrations")," script had generated a PR, the changes were integrated through another ",(0,i.yg)("a",{parentName:"li",href:"https://github.com/fedora-modularity/libmodulemd/commit/c6ffc068985ded1e3cb6875762eaa8803b63052d"},"PR"),"."),(0,i.yg)("li",{parentName:"ul"},"However, the downstream configuration remained inconsistent and was throwing errors in packit service, thus I ",(0,i.yg)("a",{parentName:"li",href:"https://src.fedoraproject.org/rpms/libmodulemd/pull-request/38"},"created a PR manually"))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},"specfile_path: fedora/libmodulemd.spec\nupstream_package_name: libmodulemd\nupstream_project_url: https://github.com/fedora-modularity/libmodulemd\ndownstream_package_name: libmodulemd\n\nactions:\n  get-current-version: ./get_version.sh\n\nfiles_to_sync:\n  - fedora/\n  - .packit.yaml\n\njobs:\n  - job: sync_from_downstream\n    trigger: commit\n\n  - job: copr_build\n    trigger: pull_request\n    metadata:\n      targets:\n        - fedora-all\n        - epel-7\n        - epel-8\n        - centos-stream-9\n")),(0,i.yg)("h3",{id:"the-problems"},"The problems"),(0,i.yg)("p",null,"The first problem I see is that the downstream configuration remains inconsistent until a ",(0,i.yg)("inlineCode",{parentName:"p"},"propose-downstream")," is performed and sometimes even later (I saw a ",(0,i.yg)("a",{parentName:"p",href:"https://src.fedoraproject.org/fork/packit/rpms/libxcrypt/c/1488467390566ebc3fd1ab8e58e510da091c4d8e"},"user")," not accepting the PRs created by packit and thus letting the downstream config broken)."),(0,i.yg)("p",null,"The second problem is the inconsistent upstream configuration, if I am not mistaken, the users want both the packit downstream configuration copied from the upstream and the other way around (I would say that, in this case, the ",(0,i.yg)("inlineCode",{parentName:"p"},"sync_from_downstream")," job should not exist and it is the one that triggers the ",(0,i.yg)("inlineCode",{parentName:"p"},"Cannot load package config")," exceptions running packit-service against the dist-git configuration). Even though the problem here is easily solved, I think this is a good example of how hard it is for our users (and not only) to understand which key belongs to which automation and be sure they are not conflicting."),(0,i.yg)("p",null,"What if the downstream configuration also has a ",(0,i.yg)("inlineCode",{parentName:"p"},"pull-from-upstream")," job and diverges from the upstream? This is obviously an error, but still not easily understandable."),(0,i.yg)("h3",{id:"possible-solutions"},"Possible solutions"),(0,i.yg)("p",null,"I think it could be helpful process the config against a template (a default one, just for packit service) before loading it; we can easily remove the not needed keys and minimize the inconsistencies (probably we can also easily rename keys, making the next breaking changes in packit less painful in service). Nonetheless, we should find a way to show us and the users how the config appears after we process it."),(0,i.yg)("p",null,"It could be helpful to increase awareness of which sections of the config are affecting which automation (upstream ci, downstream sync release) when showing the post processed configuration."),(0,i.yg)("p",null,"Since we are copying the configuration from the upstream to the downstream, almost every time, we can not simply say that the upstream config is just for the ",(0,i.yg)("em",{parentName:"p"},"upstream ci")," and the downstream config works for the ",(0,i.yg)("em",{parentName:"p"},"downstream sync"),", we already have a mix of both. And we need to increase awareness for the users (and us) on which key belongs and affect which automation."),(0,i.yg)("p",null,"It is useful to have the complete configuration (upstream ci + downstream sync release) also downstream. Because the packit.yaml file could be used via Packit CLI in a downstream repo, as an example to trigger a copr build. But, not always the downstream config is managed by an upstream one, thus I think we should make it more visible and more consistent when it is and when it is not.\n",(0,i.yg)("strong",{parentName:"p"},"Referring a configuration")," can be useful here, instead of copying the packit configuration downstream (only when a propose-downstream is performed) we can make the downstream configuration always consistent by ",(0,i.yg)("em",{parentName:"p"},"referencing the upstream one"),". If a project has both a packit upstream config and a downstream one then its downstream config should probably reference the upstream, however the downstream can choose to remove the upstream reference and let the configurations diverge. If there is no upstream config reference then the downstream config can implicitly refer to a default ",(0,i.yg)("em",{parentName:"p"},"downstream sync")," packit service template."),(0,i.yg)("h1",{id:"overall-proposed-solution"},"Overall proposed solution"),(0,i.yg)("p",null,"We chose to follow a ",(0,i.yg)("em",{parentName:"p"},"bottom-up")," global config solution ",(0,i.yg)("strong",{parentName:"p"},"but")," for the ",(0,i.yg)("em",{parentName:"p"},"fedora distgit ci")," we start with a ",(0,i.yg)("em",{parentName:"p"},"top down")," solution."),(0,i.yg)("p",null,"We will not have every package in Fedora enrolled in our ",(0,i.yg)("em",{parentName:"p"},"fedora distgit ci")," at the beginning, therefore we can start listing the ",(0,i.yg)("em",{parentName:"p"},"few")," allowed packages in our internal packit service configuration file. When packit would be enabled for most/all of the Fedora packages we can change the approach and let the packages opt-out or customize their ",(0,i.yg)("em",{parentName:"p"},"fedora distgit ci")," packit experience through a configuration that lives in their project ",(0,i.yg)("inlineCode",{parentName:"p"},"packit.yaml")," file."),(0,i.yg)("p",null,"In the meantime we can implement the ",(0,i.yg)("em",{parentName:"p"},"bottom-up-> templating + overlay")," mechanism and apply it to ",(0,i.yg)("inlineCode",{parentName:"p"},"packit"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"specfile")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"ogr"),' distgit configurations.\nLater, if this is working well for us, we can propose "middle layer templates" for groups of packages.'),(0,i.yg)("p",null,"As a result for the first implementation we should be able to put a ",(0,i.yg)("inlineCode",{parentName:"p"},"config")," key in ",(0,i.yg)("a",{parentName:"p",href:"https://src.fedoraproject.org/rpms/packit/blob/rawhide/f/.packit.yaml"},"https://src.fedoraproject.org/rpms/packit/blob/rawhide/f/.packit.yaml")," that references the upstream packit config ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/packit/packit/blob/main/.packit.yaml"},"https://github.com/packit/packit/blob/main/.packit.yaml")," and ideally remove any other existing key; the downstream sync release for packit should not be affected by the change!"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"we need to add a ",(0,i.yg)("inlineCode",{parentName:"li"},"config")," key to the schema"),(0,i.yg)("li",{parentName:"ul"},"we need to load the packit.yaml file and search for the ",(0,i.yg)("inlineCode",{parentName:"li"},"config")," key in it. If a ",(0,i.yg)("inlineCode",{parentName:"li"},"config")," key is found we need to ",(0,i.yg)("strong",{parentName:"li"},"recursively")," - at the beginning we could also have a limited depth of 3/n steps and no more and then we can choose to implement some recursion detection algorithm if more than a couple of steps are needed - look for the parent configs and start processing all the templates in the chain, creating a new temporary packit.yml that will be used instead of the original one.\nWe should make the new code work both for the packit CLI and the packit-service. Thinking at packit CLI, we should probably stay flexible and let the ",(0,i.yg)("inlineCode",{parentName:"li"},"base: URI")," be also a local url (like ",(0,i.yg)("inlineCode",{parentName:"li"},"file:///"),")."),(0,i.yg)("li",{parentName:"ul"},"we need to decide how to deal with ",(0,i.yg)("inlineCode",{parentName:"li"},"files_to_sync: packit.yml"),"; probably we can just remove it from the upstream config. But we should think what to do when ",(0,i.yg)("inlineCode",{parentName:"li"},"files_to_sync")," is not defined at all (that means packit.yml is always copied from upstream to downstream), probably in those cases (which are most of the downstream sync only automations) there is no need for copying packit by default?"),(0,i.yg)("li",{parentName:"ul"},"let the user know what the final configuration looks like (both for CLI and service); we should probably implement a CLI command that outputs the result of the pre-processing, and use it later in service. Would be nice if the output shows clearly which key affects which ",(0,i.yg)("em",{parentName:"li"},"automation chain")," (upstream ci, downstream sync release, downstream ci...)"),(0,i.yg)("li",{parentName:"ul"},"we can also implement the default internal packit-service base template (I would just start with one, and see later if having more of them can be useful). We can try, as an example, to remove the ",(0,i.yg)("a",{parentName:"li",href:"https://github.com/packit/packit/issues/2509"},(0,i.yg)("inlineCode",{parentName:"a"},"metadata")," key")," through it. In this way, when we will work on the linked card, we will be able to release a breaking change in packit, without breaking the packit service automation. We can always propose updates for the users configurations, but if our users don't accept them we can still work with the old configurations, at least on the packit service side.")))}m.isMDXComponent=!0}}]);