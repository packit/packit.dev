"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[46568],{15680:(e,n,a)=>{a.d(n,{xA:()=>c,yg:()=>u});var t=a(96540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=t.createContext({}),p=function(e){var n=t.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},c=function(e){var n=p(e.components);return t.createElement(l.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},g=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),g=i,u=d["".concat(l,".").concat(g)]||d[g]||m[g]||r;return a?t.createElement(u,o(o({ref:n},c),{},{components:a})):t.createElement(u,o({ref:n},c))}));function u(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}g.displayName="MDXCreateElement"},24113:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var t=a(58168),i=(a(96540),a(15680));const r={title:"Advanced usage of the specfile library",date:new Date("2025-01-09T00:00:00.000Z"),authors:"nforro",tags:["specfile"]},o="Advanced usage of the specfile library",s={permalink:"/posts/specfile-advanced",editUrl:"https://github.com/packit/packit.dev/tree/main/posts/specfile-advanced/index.md",source:"@site/posts/specfile-advanced/index.md",title:"Advanced usage of the specfile library",description:"Are you already familiar with the basic concepts of the specfile library?",date:"2025-01-09T00:00:00.000Z",formattedDate:"January 9, 2025",tags:[{label:"specfile",permalink:"/posts/tags/specfile"}],readingTime:6.12,hasTruncateMarker:!0,authors:[{name:"Nikola Forr\xf3",email:"nforro@redhat.com",url:"https://github.com/nforro",imageURL:"https://github.com/nforro.png",key:"nforro"}],frontMatter:{title:"Advanced usage of the specfile library",date:"2025-01-09T00:00:00.000Z",authors:"nforro",tags:["specfile"]},nextItem:{title:"Packit in 2024",permalink:"/posts/packit-in-2024"}},l={authorsImageUrls:[void 0]},p=[{value:"Forced parsing",id:"forced-parsing",level:2},{value:"Defining and undefining macros",id:"defining-and-undefining-macros",level:2},{value:"Conditions and expansion",id:"conditions-and-expansion",level:2},{value:"Validity",id:"validity",level:3},{value:"Expression expansion",id:"expression-expansion",level:3},{value:"Making modifications less obstructive",id:"making-modifications-less-obstructive",level:2},{value:"More info and links",id:"more-info-and-links",level:2}],c={toc:p},d="wrapper";function m(e){let{components:n,...a}=e;return(0,i.yg)(d,(0,t.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"Are you already familiar with the basic concepts of the ",(0,i.yg)("em",{parentName:"p"},"specfile")," library?\nThen welcome to a collection of some slightly more advanced topics that you could find useful.\nIf you're not that familiar and would like to start with something easier,\nyou can take a look at ",(0,i.yg)("a",{parentName:"p",href:"/posts/specfile-introduction"},"Introduction to specfile library"),"."),(0,i.yg)("h2",{id:"forced-parsing"},"Forced parsing"),(0,i.yg)("p",null,"Imagine you want to make changes to a spec file that requires some sources\nto be present at the time of parsing such as sources referenced from shell\nexpansions (e.g. ",(0,i.yg)("inlineCode",{parentName:"p"},"%(date +%F -r %{SOURCE0})"),"), includes some external files\nusing the ",(0,i.yg)("inlineCode",{parentName:"p"},"%include")," directive, or loads external macrofiles with the ",(0,i.yg)("inlineCode",{parentName:"p"},"%load")," macro,\nbut all you have is the spec file itself."),(0,i.yg)("p",null,"In such case you may want to instantiate ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile")," with the ",(0,i.yg)("inlineCode",{parentName:"p"},"force_parse")," argument\nset to ",(0,i.yg)("inlineCode",{parentName:"p"},"True")," in order to attempt to parse the spec file with missing external files.\nIf that succeeds and some required external files were indeed missing during parsing,\nthe ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile.tainted")," property is set to ",(0,i.yg)("inlineCode",{parentName:"p"},"True")," to indicate that certain assumptions\ncould be broken - for example a condition that relies on a macro defined in an external\nmacrofile could be evaluated incorrectly."),(0,i.yg)("h2",{id:"defining-and-undefining-macros"},"Defining and undefining macros"),(0,i.yg)("p",null,"You can define or undefine any RPM macros before parsing a spec file with the ",(0,i.yg)("inlineCode",{parentName:"p"},"macros"),"\nargument to the ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile")," constructor. The argument takes a list of 2-string tuples\nwhere the first element is macro name and the second element is macro value.\nIf the second element is ",(0,i.yg)("inlineCode",{parentName:"p"},"None"),", the macro will be undefined. This can come in handy\nwhen you need to undefine a system macro such as ",(0,i.yg)("inlineCode",{parentName:"p"},"fedora"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'from specfile import Specfile\n\nspec = Specfile(\n    "example.spec",\n    macros=[\n        ("fedora", None),\n        ("epel", "9"),\n    ],\n)\n')),(0,i.yg)("p",null,"It is also possible to pass macro definitions in the same format as the ",(0,i.yg)("inlineCode",{parentName:"p"},"extra_macros"),"\nargument to the ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile.expand()")," method in order to temporarily define or undefine macros\nbefore expression expansion."),(0,i.yg)("p",null,"For example, the following code snippet will print the expanded value of the ",(0,i.yg)("inlineCode",{parentName:"p"},"Release")," tag\nwithout system dist tag:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'spec = Specfile("example.spec")\n\nprint(spec.expand("%release", extra_macros=[("dist", None)]))\n')),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"This is just for demonstration of ",(0,i.yg)("inlineCode",{parentName:"p"},"extra_macros"),", you can achieve the same with:"),(0,i.yg)("pre",{parentName:"admonition"},(0,i.yg)("code",{parentName:"pre",className:"language-python"},'spec = Specfile("example.spec")\n\nprint(spec.expanded_release)\n'))),(0,i.yg)("h2",{id:"conditions-and-expansion"},"Conditions and expansion"),(0,i.yg)("h3",{id:"validity"},"Validity"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"MacroDefinition"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Tag"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"SourceListEntry"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Source")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Patch")," classes have a ",(0,i.yg)("inlineCode",{parentName:"p"},"valid")," attribute\nthat determines if the respective entity is in a true branch of a condition (provided that the condition\nis not present in a false branch of another condition)."),(0,i.yg)("p",null,"Having the following in a spec file:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-specfile"},"%if %{defined copr_username}\nEpoch: 102\n%else\nEpoch: 2\n%endif\n")),(0,i.yg)("p",null,"You can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Tag.valid")," attribute to choose the suitable ",(0,i.yg)("inlineCode",{parentName:"p"},"Epoch")," tag based on validity:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'from specfile import Specfile\n\nspec = Specfile("example.spec")\n\nwith spec.tags() as tags:\n    epoch_tags = [t for t in tags if t.normalized_name == "Epoch"]\n    # print the value of the first Epoch tag, disregarding the condition\n    print(epoch_tags[0].value)\n    # print the value of the first valid Epoch tag\n    print(next(t for t in epoch_tags if t.valid).value)\n    # when accessing tags by name the first valid one is chosen,\n    # so this does the same as above\n    print(tags.epoch.value)\n')),(0,i.yg)("h3",{id:"expression-expansion"},"Expression expansion"),(0,i.yg)("p",null,"You can get expanded values of tags with their ",(0,i.yg)("inlineCode",{parentName:"p"},"expanded_value")," property. This is the literal\nvalue of a tag as present in the spec file that is passed to ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile.expand()")," for expansion."),(0,i.yg)("p",null,"If you are not interested in modification and want to get exactly what ",(0,i.yg)("inlineCode",{parentName:"p"},"rpmspec --parse example.spec"),"\nwould give you, you can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile.parsed_sections")," property:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'spec = Specfile("example.spec")\n\nwith spec.tags(spec.parsed_sections.package) as tags:\n    print(tags.version.value)\n')),(0,i.yg)("p",null,"Doing this means that all conditions and macros will be already expanded, so all tags will be valid\nand their ",(0,i.yg)("inlineCode",{parentName:"p"},"value")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"expanded_value")," will be the same. Modifications will have no effect."),(0,i.yg)("p",null,"You can also access the underlying ",(0,i.yg)("inlineCode",{parentName:"p"},"rpm.spec")," object with the ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile.rpm_spec")," property,\nwhich allows you to do things like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'spec = Specfile("example.spec")\n\nprint(spec.rpm_spec.sourceHeader.epoch)\n')),(0,i.yg)("p",null,"In this case the printed value will be a number, not a string like in previous cases."),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("p",{parentName:"admonition"},"This means you have 3 ways how to get expanded value of a tag with the ",(0,i.yg)("em",{parentName:"p"},"specfile")," library.\nAll of them should give you same or very similar results, but only the first one gives you access\nalso to the unexpanded value of a tag and the possibility to modify it. On the other hand it will\nalso take the most time, so think twice if performance is a concern.")),(0,i.yg)("h2",{id:"making-modifications-less-obstructive"},"Making modifications less obstructive"),(0,i.yg)("p",null,"Consider the following in a spec file:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-specfile"},"#global rc_ver 3\n%global maj_ver 12\n%global min_ver 0\n%global patch_ver 1\n\nName:       %{pkg_name}\nVersion:    %{maj_ver}.%{min_ver}.%{patch_ver}%{?rc_ver:~rc%{rc_ver}}\n")),(0,i.yg)("p",null,"Rather than replacing the value of ",(0,i.yg)("inlineCode",{parentName:"p"},"Version")," with a version string, removing all the macro\nsubstitutions in the process, you can use ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile.update_tag()")," and have it try to update\nthe relevant macro definitions instead:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'from specfile import Specfile\n\nspec = Specfile("example.spec")\n\nspec.update_tag("Version", "12.1.0")\n')),(0,i.yg)("p",null,"This will result in:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-specfile"},"#global rc_ver 3\n%global maj_ver 12\n%global min_ver 1\n%global patch_ver 0\n\nName:       %{pkg_name}\nVersion:    %{maj_ver}.%{min_ver}.%{patch_ver}%{?rc_ver:~rc%{rc_ver}}\n")),(0,i.yg)("p",null,"It will even uncomment a commented-out macro definition if needed:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'spec = Specfile("example.spec")\n\nspec.update_tag("Version", "12.1.1~rc1")\n')),(0,i.yg)("p",null,"This will result in:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-specfile"},"%global rc_ver 1\n%global maj_ver 12\n%global min_ver 1\n%global patch_ver 1\n\nName:       %{pkg_name}\nVersion:    %{maj_ver}.%{min_ver}.%{patch_ver}%{?rc_ver:~rc%{rc_ver}}\n")),(0,i.yg)("p",null,"However, if you want to go back to a regular version, you have to comment out the relevant\nmacro definition explicitly:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'from specfile import Specfile\nfrom specfile.macro_definitions import CommentOutStyle\n\nspec = Specfile("example.spec")\n\nwith spec.macro_definitions() as macro_definitions:\n    # use the original comment-out style\n    macro_definitions.rc_ver.comment_out_style = CommentOutStyle.HASH\n    macro_definitions.rc_ver.commented_out = True\n\nspec.update_tag("Version", "12.1.1")\n')),(0,i.yg)("p",null,"This will result in:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-specfile"},"#global rc_ver 1\n%global maj_ver 12\n%global min_ver 1\n%global patch_ver 1\n\nName:       %{pkg_name}\nVersion:    %{maj_ver}.%{min_ver}.%{patch_ver}%{?rc_ver:~rc%{rc_ver}}\n")),(0,i.yg)("p",null,"The algorithm isn't perfect and won't work in all situations, but even if it's not possible to update\nsome macro definitions it is guaranteed that ",(0,i.yg)("inlineCode",{parentName:"p"},"expanded_value")," of a tag after calling ",(0,i.yg)("inlineCode",{parentName:"p"},"update_tag()"),"\nwill be equal to the given value."),(0,i.yg)("p",null,"There is also a more general method ",(0,i.yg)("inlineCode",{parentName:"p"},"Specfile.update_value()")," that allows you to update any string\nwithin a spec file in the same manner, trying to preserve macro substitutions and update relevant\nmacro definitions (or even tag values in case of e.g. ",(0,i.yg)("inlineCode",{parentName:"p"},"%{version}"),") if possible. It is up to you\nto replace the original string with the result (that can but doesn't have to be exactly the same)."),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("p",{parentName:"admonition"},"The algorithm first tokenizes the string to be updated. Then it determines which macro substitutions\nwithin the string can be affected by modifying bodies of preceding macro definitions or values\nof preceding tags. Then it identifies substrings that are deemed modifiable (that could be for example\na sequence of numbers between two dots) and constructs a regular expression in which the modifiable\nmacro substitutions and the modifiable substrings are capturing groups.\nIf the requested new string is a not match to this regular expression, nothing happens and the requested\nnew string is returned unchanged. If it is a match though, the captured groups corresponding to modifiable\nmacro substitutions are processed, recursively, starting with tokenization once again. The requested\nnew string is then updated with corresponding macro substitutions from the original string and returned.")),(0,i.yg)("h2",{id:"more-info-and-links"},"More info and links"),(0,i.yg)("p",null,"Are you interested in more details, trying the library out or even contributing?\nYou can find ",(0,i.yg)("em",{parentName:"p"},"specfile")," source code on ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/packit/specfile"},"GitHub"),".\nSee the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/packit/specfile/blob/main/README.md"},"README")," for more tips and usage examples.\nYou can also check out the ",(0,i.yg)("a",{parentName:"p",href:"https://packit.dev/specfile/api/specfile"},"API reference"),"."))}m.isMDXComponent=!0}}]);