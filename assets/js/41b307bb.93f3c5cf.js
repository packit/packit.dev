"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[54766],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(n),m=l,k=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return n?a.createElement(k,r(r({ref:t},u),{},{components:n})):a.createElement(k,r({ref:t},u))}));function k(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:l,r[1]=o;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},72137:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(87462),l=(n(67294),n(3905));const i={sidebar_label:"specfile",title:"specfile.specfile"},r=void 0,o={unversionedId:"api/specfile/specfile",id:"api/specfile/specfile",title:"specfile.specfile",description:"Specfile",source:"@site/specfile/api/specfile/specfile.md",sourceDirName:"api/specfile",slug:"/api/specfile/",permalink:"/specfile/api/specfile/",draft:!1,editUrl:"https://github.com/packit/specfile/tree/main/docs/specfile/api/specfile/specfile.md",tags:[],version:"current",frontMatter:{sidebar_label:"specfile",title:"specfile.specfile"},sidebar:"autogenerated",next:{title:"changelog",permalink:"/specfile/api/specfile/changelog"}},s={},p=[{value:"Specfile",id:"specfile",level:2},{value:"__init__",id:"__init__",level:4},{value:"path",id:"path",level:4},{value:"sourcedir",id:"sourcedir",level:4},{value:"macros",id:"macros",level:4},{value:"force_parse",id:"force_parse",level:4},{value:"tainted",id:"tainted",level:4},{value:"rpm_spec",id:"rpm_spec",level:4},{value:"reload",id:"reload",level:4},{value:"save",id:"save",level:4},{value:"expand",id:"expand",level:4},{value:"get_active_macros",id:"get_active_macros",level:4},{value:"lines",id:"lines",level:4},{value:"macro_definitions",id:"macro_definitions",level:4},{value:"sections",id:"sections",level:4},{value:"parsed_sections",id:"parsed_sections",level:4},{value:"tags",id:"tags",level:4},{value:"changelog",id:"changelog",level:4},{value:"prep",id:"prep",level:4},{value:"sources",id:"sources",level:4},{value:"patches",id:"patches",level:4},{value:"has_autorelease",id:"has_autorelease",level:4},{value:"contains_autochangelog",id:"contains_autochangelog",level:4},{value:"has_autochangelog",id:"has_autochangelog",level:4},{value:"add_changelog_entry",id:"add_changelog_entry",level:4},{value:"release",id:"release",level:4},{value:"expanded_release",id:"expanded_release",level:4},{value:"set_version_and_release",id:"set_version_and_release",level:4},{value:"add_patch",id:"add_patch",level:4},{value:"update_value",id:"update_value",level:4},{value:"update_tag",id:"update_tag",level:4},{value:"update_version",id:"update_version",level:4},{value:"bump_release",id:"bump_release",level:4}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,l.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"specfile"},"Specfile"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class Specfile()\n")),(0,l.kt)("p",null,"Class that represents a spec file."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"autosave")," - Whether to automatically save any changes made.")),(0,l.kt)("h4",{id:"__init__"},"_","_","init","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(path: Union[Path, str],\n             sourcedir: Optional[Union[Path, str]] = None,\n             autosave: bool = False,\n             macros: Optional[List[Tuple[str, Optional[str]]]] = None,\n             force_parse: bool = False) -> None\n")),(0,l.kt)("p",null,"Initializes a specfile object."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"path")," - Path to the spec file."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sourcedir")," - Path to sources and patches."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"autosave")," - Whether to automatically save any changes made."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"macros")," - List of extra macro definitions."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"force_parse")," - Whether to attempt to parse the spec file even if one or more\nsources required to be present at parsing time are not available.\nSuch sources include sources referenced from shell expansions\nin tag values and sources included using the ",(0,l.kt)("em",{parentName:"li"},"%include")," directive.")),(0,l.kt)("h4",{id:"path"},"path"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef path() -> Path\n")),(0,l.kt)("p",null,"Path to the spec file."),(0,l.kt)("h4",{id:"sourcedir"},"sourcedir"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef sourcedir() -> Path\n")),(0,l.kt)("p",null,"Path to sources and patches."),(0,l.kt)("h4",{id:"macros"},"macros"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef macros() -> List[Tuple[str, Optional[str]]]\n")),(0,l.kt)("p",null,"List of extra macro definitions."),(0,l.kt)("h4",{id:"force_parse"},"force","_","parse"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef force_parse() -> bool\n")),(0,l.kt)("p",null,"Whether to attempt to parse the spec file even if one or more\nsources required to be present at parsing time are not available."),(0,l.kt)("h4",{id:"tainted"},"tainted"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef tainted() -> bool\n")),(0,l.kt)("p",null,"Indication that parsing of the spec file was forced and one or more\nsources required to be present at parsing time were not available\nand were replaced with dummy files."),(0,l.kt)("h4",{id:"rpm_spec"},"rpm","_","spec"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef rpm_spec() -> rpm.spec\n")),(0,l.kt)("p",null,"Underlying ",(0,l.kt)("inlineCode",{parentName:"p"},"rpm.spec")," instance."),(0,l.kt)("h4",{id:"reload"},"reload"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def reload() -> None\n")),(0,l.kt)("p",null,"Reloads the spec file content."),(0,l.kt)("h4",{id:"save"},"save"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def save() -> None\n")),(0,l.kt)("p",null,"Saves the spec file content."),(0,l.kt)("h4",{id:"expand"},"expand"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def expand(expression: str,\n           extra_macros: Optional[List[Tuple[str, Optional[str]]]] = None,\n           skip_parsing: bool = False) -> str\n")),(0,l.kt)("p",null,"Expands an expression in the context of the spec file."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"expression")," - Expression to expand."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"extra_macros")," - Extra macros to be defined before expansion is performed."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"skip_parsing")," - Do not parse the spec file before expansion is performed.\nDefaults to ",(0,l.kt)("inlineCode",{parentName:"li"},"False"),". Mutually exclusive with ",(0,l.kt)("inlineCode",{parentName:"li"},"extra_macros"),". Set this to ",(0,l.kt)("inlineCode",{parentName:"li"},"True"),"\nonly if you are certain that the global macro context is up-to-date.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  Expanded expression."),(0,l.kt)("h4",{id:"get_active_macros"},"get","_","active","_","macros"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def get_active_macros() -> List[Macro]\n")),(0,l.kt)("p",null,"Gets active macros in the context of the spec file."),(0,l.kt)("p",null,"This includes built-in RPM macros, macros loaded from macro files\nand macros defined in the spec file itself."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  List of ",(0,l.kt)("inlineCode",{parentName:"p"},"Macro")," objects."),(0,l.kt)("h4",{id:"lines"},"lines"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@ContextManager\ndef lines() -> Generator[List[str], None, None]\n")),(0,l.kt)("p",null,"Context manager for accessing spec file lines."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Spec file lines as list of strings."),(0,l.kt)("h4",{id:"macro_definitions"},"macro","_","definitions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@ContextManager\ndef macro_definitions() -> Generator[MacroDefinitions, None, None]\n")),(0,l.kt)("p",null,"Context manager for accessing macro definitions."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Macro definitions in the spec file as ",(0,l.kt)("inlineCode",{parentName:"p"},"MacroDefinitions")," object."),(0,l.kt)("h4",{id:"sections"},"sections"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@ContextManager\ndef sections() -> Generator[Sections, None, None]\n")),(0,l.kt)("p",null,"Context manager for accessing spec file sections."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Spec file sections as ",(0,l.kt)("inlineCode",{parentName:"p"},"Sections")," object."),(0,l.kt)("h4",{id:"parsed_sections"},"parsed","_","sections"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef parsed_sections() -> Sections\n")),(0,l.kt)("p",null,"Parsed spec file sections."),(0,l.kt)("h4",{id:"tags"},"tags"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'@ContextManager\ndef tags(\n        section: Union[str,\n                       Section] = "package") -> Generator[Tags, None, None]\n')),(0,l.kt)("p",null,"Context manager for accessing tags in a specified section."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"section")," - Name of the requested section or an existing ",(0,l.kt)("inlineCode",{parentName:"li"},"Section")," instance.\nDefaults to preamble.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Tags in the section as ",(0,l.kt)("inlineCode",{parentName:"p"},"Tags")," object."),(0,l.kt)("h4",{id:"changelog"},"changelog"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@ContextManager\ndef changelog(\n    section: Optional[Section] = None\n) -> Generator[Optional[Changelog], None, None]\n")),(0,l.kt)("p",null,"Context manager for accessing changelog."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"section")," - Optional ",(0,l.kt)("inlineCode",{parentName:"li"},"Section")," instance to be processed. If not set, the first\n",(0,l.kt)("em",{parentName:"li"},"%changelog")," section (if any) will be processed.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Spec file changelog as ",(0,l.kt)("inlineCode",{parentName:"p"},"Changelog")," object or ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if there is no ",(0,l.kt)("em",{parentName:"p"},"%changelog")," section."),(0,l.kt)("h4",{id:"prep"},"prep"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@ContextManager\ndef prep() -> Generator[Optional[Prep], None, None]\n")),(0,l.kt)("p",null,"Context manager for accessing ",(0,l.kt)("em",{parentName:"p"},"%prep")," section."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Spec file ",(0,l.kt)("em",{parentName:"p"},"%prep")," section as ",(0,l.kt)("inlineCode",{parentName:"p"},"Prep")," object."),(0,l.kt)("h4",{id:"sources"},"sources"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@ContextManager\ndef sources(\n        allow_duplicates: bool = False,\n        default_to_implicit_numbering: bool = False,\n        default_source_number_digits: int = 1\n) -> Generator[Sources, None, None]\n")),(0,l.kt)("p",null,"Context manager for accessing sources."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allow_duplicates")," - Whether to allow duplicate entries when adding new sources."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"default_to_implicit_numbering")," - Use implicit numbering (no source numbers) by default."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"default_source_number_digits")," - Default number of digits in a source number.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Spec file sources as ",(0,l.kt)("inlineCode",{parentName:"p"},"Sources")," object."),(0,l.kt)("h4",{id:"patches"},"patches"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@ContextManager\ndef patches(\n        allow_duplicates: bool = False,\n        default_to_implicit_numbering: bool = False,\n        default_source_number_digits: int = 1\n) -> Generator[Patches, None, None]\n")),(0,l.kt)("p",null,"Context manager for accessing patches."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allow_duplicates")," - Whether to allow duplicate entries when adding new patches."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"default_to_implicit_numbering")," - Use implicit numbering (no source numbers) by default."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"default_source_number_digits")," - Default number of digits in a source number.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Yields"),":"),(0,l.kt)("p",null,"  Spec file patches as ",(0,l.kt)("inlineCode",{parentName:"p"},"Patches")," object."),(0,l.kt)("h4",{id:"has_autorelease"},"has","_","autorelease"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef has_autorelease() -> bool\n")),(0,l.kt)("p",null,"Whether the spec file uses ",(0,l.kt)("em",{parentName:"p"},"%autorelease"),"."),(0,l.kt)("h4",{id:"contains_autochangelog"},"contains","_","autochangelog"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@staticmethod\ndef contains_autochangelog(section: Section) -> bool\n")),(0,l.kt)("p",null,"Determines if the specified section contains the ",(0,l.kt)("em",{parentName:"p"},"%autochangelog")," macro."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"section")," - Section to examine.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  ",(0,l.kt)("inlineCode",{parentName:"p"},"True")," if the section contains ",(0,l.kt)("em",{parentName:"p"},"%autochangelog"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,l.kt)("h4",{id:"has_autochangelog"},"has","_","autochangelog"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef has_autochangelog() -> bool\n")),(0,l.kt)("p",null,"Whether the spec file uses ",(0,l.kt)("em",{parentName:"p"},"%autochangelog"),"."),(0,l.kt)("h4",{id:"add_changelog_entry"},"add","_","changelog","_","entry"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def add_changelog_entry(entry: Union[str, List[str]],\n                        author: Optional[str] = None,\n                        email: Optional[str] = None,\n                        timestamp: Optional[Union[datetime.date,\n                                                  datetime.datetime]] = None,\n                        evr: Optional[str] = None) -> None\n")),(0,l.kt)("p",null,"Adds a new ",(0,l.kt)("em",{parentName:"p"},"%changelog")," entry. Does nothing if there is no ",(0,l.kt)("em",{parentName:"p"},"%changelog")," section\nor if ",(0,l.kt)("em",{parentName:"p"},"%autochangelog")," is being used."),(0,l.kt)("p",null,"If not specified, author and e-mail will be automatically determined, if possible.\nTimestamp, if not set, will be set to current time (in local timezone)."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"entry")," - Entry text or list of entry lines."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"author")," - Author of the entry."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"email")," - E-mail of the author."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"timestamp")," - Timestamp of the entry.\nSupply ",(0,l.kt)("inlineCode",{parentName:"li"},"datetime")," rather than ",(0,l.kt)("inlineCode",{parentName:"li"},"date")," for extended format."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"evr")," - Override the EVR part of the changelog entry.\nMacros will be expanded automatically. By default, the function\ndetermines the appropriate value based on the spec file current\n",(0,l.kt)("em",{parentName:"li"},"%","{","epoch","}"),", ",(0,l.kt)("em",{parentName:"li"},"%","{","version","}"),", and ",(0,l.kt)("em",{parentName:"li"},"%","{","release","}")," values.")),(0,l.kt)("h4",{id:"release"},"release"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef release() -> str\n")),(0,l.kt)("p",null,"Release string without the dist suffix."),(0,l.kt)("h4",{id:"expanded_release"},"expanded","_","release"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef expanded_release() -> str\n")),(0,l.kt)("p",null,"Release string without the dist suffix with macros expanded."),(0,l.kt)("h4",{id:"set_version_and_release"},"set","_","version","_","and","_","release"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'def set_version_and_release(version: str, release: str = "1") -> None\n')),(0,l.kt)("p",null,"Sets both version and release at the same time."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"version")," - Version string."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"release")," - Release string, defaults to ",'"',"1",'"',".")),(0,l.kt)("h4",{id:"add_patch"},"add","_","patch"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def add_patch(location: str,\n              number: Optional[int] = None,\n              comment: Optional[str] = None,\n              initial_number: int = 0,\n              number_digits: int = 4) -> None\n")),(0,l.kt)("p",null,"Adds a patch."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"location")," - Patch location (filename or URL)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number")," - Patch number. It will be auto-assigned if not specified.\nIf specified, it must be higher than any existing patch number."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"comment")," - Associated comment."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"initial_number")," - Auto-assigned number to start with if there are no patches."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number_digits")," - Number of digits in the patch number.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Raises"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"SourceNumberException")," - If the specified patch number is not higher\nthan any existing patch number.")),(0,l.kt)("h4",{id:"update_value"},"update","_","value"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def update_value(value: str,\n                 requested_value: str,\n                 position: int,\n                 protected_entities: Optional[str] = None) -> str\n")),(0,l.kt)("p",null,"Updates a value from within the context of the spec file with a new value,\nbut tries to preserve substitutions of locally defined macros and tags,\nupdating the respective macro definitions and tag values instead."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - Value to update."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"requested_value")," - Requested new value."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"position")," - Position (line number) of the value in the spec file."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"protected_entities")," - Regular expression specifying protected tags and macro definitions,\nensuring their values won","'","t be updated.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  Updated value. Can be equal to the original value."),(0,l.kt)("h4",{id:"update_tag"},"update","_","tag"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'def update_tag(name: str,\n               value: str,\n               protected_entities: str = ".*name") -> None\n')),(0,l.kt)("p",null,"Updates value of the given tag, trying to preserve substitutions\nof locally defined macros and tags, updating the respective macro definitions\nand tag values instead."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"name")," - Tag name."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - Requested new value."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"protected_entities")," - Regular expression specifying protected tags and macro definitions,\nensuring their values won","'","t be updated.")),(0,l.kt)("h4",{id:"update_version"},"update","_","version"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def update_version(\n        version: str,\n        prerelease_suffix_pattern: Optional[str] = None,\n        prerelease_suffix_macro: Optional[str] = None,\n        comment_out_style: CommentOutStyle = CommentOutStyle.DNL) -> None\n")),(0,l.kt)("p",null,"Updates spec file version."),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"prerelease_suffix_pattern")," is not set, this method is equivalent\nto calling ",(0,l.kt)("inlineCode",{parentName:"p"},'update_tag("Version", version)'),".\nIf ",(0,l.kt)("inlineCode",{parentName:"p"},"prerelease_suffix_pattern")," is set and the specified version matches it,\nthe detected pre-release suffix is prepended with ","'","~","'"," (any existing delimiter\nis removed) before updating Version to ensure proper sorting by RPM.\nIf ",(0,l.kt)("inlineCode",{parentName:"p"},"prerelease_suffix_macro")," is also set and such macro definition exists,\nit is commented out or uncommented accordingly before updating Version."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"version")," - Version string."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"prerelease_suffix_pattern")," - Regular expression specifying recognized\npre-release suffixes. The first capturing group must capture the delimiter\nbetween base version and pre-release suffix and can be empty in case\nthere is no delimiter."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"prerelease_suffix_macro")," - Macro definition that controls whether spec file\nversion is a pre-release and contains the pre-release suffix.\nTo be commented out or uncommented accordingly."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"comment_out_style")," - Style of commenting out ",(0,l.kt)("inlineCode",{parentName:"li"},"prerelease_suffix_macro"),".\nSee ",(0,l.kt)("inlineCode",{parentName:"li"},"CommentOutStyle"),". Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},'update_tag("Version", version)'),"0.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Raises"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'update_tag("Version", version)'),"1 - If ",(0,l.kt)("inlineCode",{parentName:"li"},"prerelease_suffix_pattern")," is invalid.")),(0,l.kt)("h4",{id:"bump_release"},"bump","_","release"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def bump_release() -> None\n")),(0,l.kt)("p",null,"Tries to bump release. Follows the logic of ",(0,l.kt)("inlineCode",{parentName:"p"},"rpmdev-bumpspec"),", first trying to update\nmacro definitions that seem to define a release, then trying to update value\nof the Release tag."))}d.isMDXComponent=!0}}]);