"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[3725],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(n),u=a,f=c["".concat(p,".").concat(u)]||c[u]||d[u]||r;return n?i.createElement(f,l(l({ref:t},m),{},{components:n})):i.createElement(f,l({ref:t},m))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[c]="string"==typeof e?e:a,l[1]=o;for(var s=2;s<r;s++)l[s]=n[s];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},69636:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var i=n(87462),a=(n(67294),n(3905));const r={sidebar_label:"macro_definitions",title:"specfile.macro_definitions"},l=void 0,o={unversionedId:"api/specfile/macro_definitions",id:"api/specfile/macro_definitions",title:"specfile.macro_definitions",description:"CommentOutStyle",source:"@site/specfile/api/specfile/macro_definitions.md",sourceDirName:"api/specfile",slug:"/api/specfile/macro_definitions",permalink:"/specfile/api/specfile/macro_definitions",draft:!1,editUrl:"https://github.com/packit/specfile/tree/main/docs/specfile/api/specfile/macro_definitions.md",tags:[],version:"current",frontMatter:{sidebar_label:"macro_definitions",title:"specfile.macro_definitions"},sidebar:"autogenerated",previous:{title:"formatter",permalink:"/specfile/api/specfile/formatter"},next:{title:"macros",permalink:"/specfile/api/specfile/macros"}},p={},s=[{value:"CommentOutStyle",id:"commentoutstyle",level:2},{value:"DNL",id:"dnl",level:4},{value:"HASH",id:"hash",level:4},{value:"OTHER",id:"other",level:4},{value:"MacroDefinition",id:"macrodefinition",level:2},{value:"__init__",id:"__init__",level:4},{value:"get_position",id:"get_position",level:4},{value:"MacroDefinitions",id:"macrodefinitions",level:2},{value:"__init__",id:"__init__-1",level:4},{value:"find",id:"find",level:4},{value:"parse",id:"parse",level:4}],m={toc:s},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"commentoutstyle"},"CommentOutStyle"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class CommentOutStyle(Enum)\n")),(0,a.kt)("p",null,"Style of commenting out a macro definition."),(0,a.kt)("h4",{id:"dnl"},"DNL"),(0,a.kt)("p",null,"Using the ",(0,a.kt)("em",{parentName:"p"},"%dnl")," macro."),(0,a.kt)("h4",{id:"hash"},"HASH"),(0,a.kt)("p",null,"Replacing ",(0,a.kt)("em",{parentName:"p"},"%")," in ",(0,a.kt)("em",{parentName:"p"},"%global"),"/",(0,a.kt)("em",{parentName:"p"},"%define")," with ",(0,a.kt)("em",{parentName:"p"},"#"),"."),(0,a.kt)("h4",{id:"other"},"OTHER"),(0,a.kt)("p",null,"Prepending the definition with ",(0,a.kt)("em",{parentName:"p"},"#")," followed by arbitrary string."),(0,a.kt)("h2",{id:"macrodefinition"},"MacroDefinition"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class MacroDefinition()\n")),(0,a.kt)("p",null,"Class that represents a macro definition. Macro definition starts with ",(0,a.kt)("em",{parentName:"p"},"%global"),"\nor ",(0,a.kt)("em",{parentName:"p"},"%define")," keyword, followed by macro name, optional argument string enclosed\nin parentheses and macro body."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"name")," - Macro name."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"body")," - Macro body."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"is_global")," - Whether the macro is defined using ",(0,a.kt)("em",{parentName:"li"},"%global")," rather than ",(0,a.kt)("em",{parentName:"li"},"%define"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"commented_out")," - Whether the definition is commented out."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"comment_out_style")," - Style of commenting out. See ",(0,a.kt)("inlineCode",{parentName:"li"},"CommentOutStyle"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"valid")," - Whether the definition is not located in a false branch of a condition.")),(0,a.kt)("h4",{id:"__init__"},"_","_","init","_","_"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def __init__(name: str,\n             body: str,\n             is_global: bool,\n             commented_out: bool,\n             comment_out_style: CommentOutStyle,\n             whitespace: Tuple[str, str, str, str],\n             prefix: str = "",\n             valid: bool = True,\n             preceding_lines: Optional[List[str]] = None) -> None\n')),(0,a.kt)("p",null,"Initializes a macro definition object."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"name")," - Macro name."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"body")," - Macro body."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"is_global")," - Whether the macro is defined using ",(0,a.kt)("em",{parentName:"li"},"%global")," rather than ",(0,a.kt)("em",{parentName:"li"},"%define"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"commented_out")," - Whether the definition is commented out."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"comment_out_style")," - Style of commenting out. See ",(0,a.kt)("inlineCode",{parentName:"li"},"CommentOutStyle"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"whitespace")," - Tuple of whitespace - (preceding the definition, preceding macro name,\npreceding macro body, following the body)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"prefix")," - String preceding the start of the definition."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"valid")," - Whether the definition is not located in a false branch of a condition."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"preceding_lines")," - Extra lines that precede the definition.")),(0,a.kt)("h4",{id:"get_position"},"get","_","position"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def get_position(container: "MacroDefinitions") -> int\n')),(0,a.kt)("p",null,"Gets position of this macro definition in the spec file."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"container")," - ",(0,a.kt)("inlineCode",{parentName:"li"},"MacroDefinitions")," instance that contains this macro definition.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("p",null,"  Position expressed as line number (starting from 0)."),(0,a.kt)("h2",{id:"macrodefinitions"},"MacroDefinitions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class MacroDefinitions(UserList[MacroDefinition])\n")),(0,a.kt)("p",null,"Class that represents a list of all macro definitions."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"data")," - List of individual macro definitions.")),(0,a.kt)("h4",{id:"__init__-1"},"_","_","init","_","_"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(data: Optional[List[MacroDefinition]] = None,\n             remainder: Optional[List[str]] = None) -> None\n")),(0,a.kt)("p",null,"Initializes a macro definitions object."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"data")," - List of individual macro definitions."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"remainder")," - Leftover lines that can","'","t be parsed into macro definitions.")),(0,a.kt)("h4",{id:"find"},"find"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def find(name: str, position: Optional[int] = None) -> int\n")),(0,a.kt)("p",null,"Finds a macro definition with the specified name. If position is not specified,\nreturns the first valid matching macro definiton. If there is no such macro\ndefinition, returns the first match, if any. If position is specified and there is\na matching macro definition at that position, it is returned, otherwise\n",(0,a.kt)("inlineCode",{parentName:"p"},"ValueError")," is raised."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"name")," - Name of the tag to find."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"position")," - Optional position in the spec file.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("p",null,"  Index of the matching tag."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Raises"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ValueError")," - If there is no match.")),(0,a.kt)("h4",{id:"parse"},"parse"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'@classmethod\ndef parse(cls,\n          lines: List[str],\n          with_conditions: bool = False,\n          context: Optional["Specfile"] = None) -> "MacroDefinitions"\n')),(0,a.kt)("p",null,"Parses given lines into macro defintions."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lines")," - Lines to parse."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"with_conditions")," - Whether to process conditions before parsing and populate\nthe ",(0,a.kt)("inlineCode",{parentName:"li"},"valid")," attribute."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"context")," - ",(0,a.kt)("inlineCode",{parentName:"li"},"Specfile")," instance that defines the context for macro expansions.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("p",null,"  New instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"MacroDefinitions")," class."))}d.isMDXComponent=!0}}]);