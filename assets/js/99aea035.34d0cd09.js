"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[38624],{15680:(e,t,o)=>{o.d(t,{xA:()=>h,yg:()=>g});var a=o(96540);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,n=function(e,t){if(null==e)return{};var o,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var o=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(o),d=n,g=p["".concat(l,".").concat(d)]||p[d]||u[d]||i;return o?a.createElement(g,r(r({ref:t},h),{},{components:o})):a.createElement(g,r({ref:t},h))}));function g(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=o.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:n,r[1]=s;for(var c=2;c<i;c++)r[c]=o[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,o)}d.displayName="MDXCreateElement"},83163:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=o(58168),n=(o(96540),o(15680));const i={title:"Automatic Configuration Updates",authors:"fnecas"},r=void 0,s={unversionedId:"ux/automatic-config-updates",id:"ux/automatic-config-updates",title:"Automatic Configuration Updates",description:"Every now end then, a need to do a backward-incompatible change in packit.yaml arises (e.g. renaming a field in the config to a more precise name).",source:"@site/research/ux/automatic-config-updates.md",sourceDirName:"ux",slug:"/ux/automatic-config-updates",permalink:"/research/ux/automatic-config-updates",draft:!1,editUrl:"https://github.com/packit/research/tree/main/research/ux/automatic-config-updates.md",tags:[],version:"current",frontMatter:{title:"Automatic Configuration Updates",authors:"fnecas"},sidebar:"autogenerated",previous:{title:"User Experience",permalink:"/research/category/user-experience"},next:{title:"Configuration versioning",permalink:"/research/ux/configuration-versioning"}},l={},c=[{value:"Possible high-level approaches",id:"possible-high-level-approaches",level:2},{value:"Implementation approach",id:"implementation-approach",level:2},{value:"Getting the config",id:"getting-the-config",level:3},{value:"Making transformations",id:"making-transformations",level:3},{value:"Creating a pull request",id:"creating-a-pull-request",level:3}],h={toc:c},p="wrapper";function u(e){let{components:t,...o}=e;return(0,n.yg)(p,(0,a.A)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,n.yg)("p",null,"Every now end then, a need to do a backward-incompatible change in ",(0,n.yg)("inlineCode",{parentName:"p"},"packit.yaml")," arises (e.g. renaming a field in the config to a more precise name).\nCurrently, we have no convenient way of telling if all users have migrated their configs to the new format (so that the previous one can be removed) which slows down the process of deprecation. Moreover, in a lot of cases, we may be able to do the transformation for the user on our end."),(0,n.yg)("h2",{id:"possible-high-level-approaches"},"Possible high-level approaches"),(0,n.yg)("p",null,"There seem to be 2 possible approaches how such updates could work on the top-level (for example the pre-commit bot does both of these):"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"When a user opens a pull request and we detect that the config in the PR can be transformed, we can push a new commit to the pull request."),(0,n.yg)("li",{parentName:"ol"},"We could periodically (or make this an action that can be triggered manually, e.g. a script that we run on the side) go over all the currently used configs and search for possible transformations and proactively make a PR to the respective repositories. This could also be run after production deployment.")),(0,n.yg)("p",null,"A disadvantage of 1) is that it requires user action (in the form of a PR).\nIf a project that has Packit enabled doesn't have any PR for a few months, during which we change the config and remove support for the old format, things like triggering ",(0,n.yg)("inlineCode",{parentName:"p"},"propose-downstream")," won't work because the config will be invalid (because there was no PR where we could update it) and unparsable.\nWith this in mind, I consider 2) to be a must-have, while 1) to be a nice-to-have."),(0,n.yg)("p",null,"On the other hand, 1) has the advantage that it can fix the config of the user before it is merged to main if they try to use a deprecated feature, which 2) can't really handle (the config would be merged and then we would create a PR with the correction, so a correct config will end up on the main branch in the end)."),(0,n.yg)("h2",{id:"implementation-approach"},"Implementation approach"),(0,n.yg)("p",null,"Regardless of which of the following approaches ends up being used, the process of updating the config will always be the following:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"Get the config, determine if transformations need to be done"),(0,n.yg)("li",{parentName:"ol"},"Pull the repository"),(0,n.yg)("li",{parentName:"ol"},"Make transformations to the config"),(0,n.yg)("li",{parentName:"ol"},"Create a pull request (or add a commit to a PR) with the transformations")),(0,n.yg)("p",null,'Let\'s take a closer look at the more "problematic" parts of this pipeline.'),(0,n.yg)("h3",{id:"getting-the-config"},"Getting the config"),(0,n.yg)("p",null,"There seem to be three main approaches to getting the config:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"In case we do the modifications by adding commits to PRs, the config should come from the PR."),(0,n.yg)("li",{parentName:"ol"},"Get the list of projects by querying ",(0,n.yg)("inlineCode",{parentName:"li"},"/api/projects")," and then find configs in them."),(0,n.yg)("li",{parentName:"ol"},"Add a new database table mapping project to its config content on main.")),(0,n.yg)("p",null,"Let's focus on comparing 2) and 3) since those are relevant to the periodic updates.\nGetting the list of projects with Packit enabled is straight-forward. However, we would have to do quite a lot of queries to Github to get all the configs (we could even run into Github's request quota).\nMoreover, with this approach, we can't store any additional information about the config, which could perhaps be useful."),(0,n.yg)("p",null,"On the other hand, 3) would spread the requests to Github to get the current config across time. We would basically have to create an implicit action that triggers on merge to main/master and fetches the current config to the database. Hence, we wouldn't be making a lot of requests to Github at the same time, but rather over time.\nThis approach also facilitates storing additional data about the configs, for example which transformations have already been applied (see the following section).\nSuch additional information could allow us to detect that there are no transformations to do without even checking the config (resulting in faster overall updates).\nThe main downside of storing the configuration in the database are the space requirements.\nHowever, this should hopefully not be a problem, since the config is usually not that long (but it is still something to keep in mind)."),(0,n.yg)("p",null,"This approach also better facilitates analyzing user configs (for example when we want to know if a feature is used or if we can remove it) because we wouldn't have to make lots of requests to Github, just working with our database would suffice."),(0,n.yg)("h3",{id:"making-transformations"},"Making transformations"),(0,n.yg)("p",null,"The process of making configuration transformations looks to be analogous to making database migrations so that's where we should take some inspiration."),(0,n.yg)("p",null,"If a code change modifies the config in a backward-incompatible way (e.g. adds a new name for a field and deprecates the old one), the author of the code should also provide a transformation which will update the configs (if it's possible to do it automatically)."),(0,n.yg)("p",null,'Each transformation should take in the config text, do some simple operations, and return the updated config (or the same config if no changes are necessary).\nThis way, we can easily chain the transformations.\nTo avoid unnecessary update attempts, we could "version" the transformations and then only try to do those which haven\'t already been applied.\nTo support this, we need to somehow map configuration to the index/version of transformation that was last applied (which would probably require approach 3) from the previous section).'),(0,n.yg)("p",null,"Before completely removing a feature, we should check if all configs have been updated which requires analyzing the configs. The fact that we automatically opened a PR does not mean that it was really merged."),(0,n.yg)("h3",{id:"creating-a-pull-request"},"Creating a pull request"),(0,n.yg)("p",null,"Creating a PR should be trivial, however, we currently don't have permissions to do so (Packit Github application only requests read permissions of code).\nAccording to ",(0,n.yg)("a",{parentName:"p",href:"https://docs.github.com/en/developers/apps/managing-github-apps/editing-a-github-apps-permissions"},"Github docs"),", we should be able to easily modify this with an explaining message to our users why we are doing this.\nHowever, from the docs, I am not sure if they somehow have to confirm Packit's permissions again or if it will work out of the box after doing the modification."))}u.isMDXComponent=!0}}]);