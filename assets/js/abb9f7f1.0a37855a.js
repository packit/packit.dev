"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[26627],{15680:(e,t,a)=>{a.d(t,{xA:()=>d,yg:()=>m});var n=a(96540);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=u(a),g=i,m=p["".concat(s,".").concat(g)]||p[g]||c[g]||r;return a?n.createElement(m,l(l({ref:t},d),{},{components:a})):n.createElement(m,l({ref:t},d))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=g;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:i,l[1]=o;for(var u=2;u<r;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},49801:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var n=a(58168),i=(a(96540),a(15680));const r={title:"Migration from Flask to FastAPI",authors:"lbarcziova"},l=void 0,o={unversionedId:"fast-api/index",id:"fast-api/index",title:"Migration from Flask to FastAPI",description:"Currently, we use Flask for our API (code).",source:"@site/research/fast-api/index.md",sourceDirName:"fast-api",slug:"/fast-api/",permalink:"/research/fast-api/",draft:!1,editUrl:"https://github.com/packit/research/tree/main/research/fast-api/index.md",tags:[],version:"current",frontMatter:{title:"Migration from Flask to FastAPI",authors:"lbarcziova"},sidebar:"autogenerated",previous:{title:"Deprecation policy",permalink:"/research/deprecation/"},next:{title:"Fedora package candidates for onboarding to downstream automation",permalink:"/research/fedora-packages-onboarding/"}},s={},u=[{value:"FastAPI",id:"fastapi",level:2},{value:"Advantages",id:"advantages",level:3},{value:"Disadvantages (from our architecture discussion)",id:"disadvantages-from-our-architecture-discussion",level:3},{value:"Considerations",id:"considerations",level:3},{value:"Migration requirements",id:"migration-requirements",level:2},{value:"Rewriting endpoints",id:"rewriting-endpoints",level:3},{value:"Implementing models",id:"implementing-models",level:3},{value:"Using Pydantic with our existing models",id:"using-pydantic-with-our-existing-models",level:4},{value:"Migrating to SQLModel",id:"migrating-to-sqlmodel",level:4},{value:"Migration approach",id:"migration-approach",level:2},{value:"Gradual rewrite",id:"gradual-rewrite",level:3},{value:"Rewrite all at once",id:"rewrite-all-at-once",level:3},{value:"Migration example",id:"migration-example",level:2},{value:"Before",id:"before",level:3},{value:"After (using Pydantic)",id:"after-using-pydantic",level:3},{value:"Useful links",id:"useful-links",level:3}],d={toc:u},p="wrapper";function c(e){let{components:t,...a}=e;return(0,i.yg)(p,(0,n.A)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"Currently, we use ",(0,i.yg)("a",{parentName:"p",href:"https://flask.palletsprojects.com/en/stable/"},"Flask")," for our API (",(0,i.yg)("a",{parentName:"p",href:"https://github.com/packit/packit-service/tree/main/packit_service/service/api"},"code"),").\nWe have been considering a potential migration to FastAPI due to its benefits over Flask (detailed below), which would also be a chance to refactor our API (and maybe also DB) code.\nThis research aims to evaluate these benefits and outline the key aspects of a possible migration."),(0,i.yg)("h2",{id:"fastapi"},(0,i.yg)("a",{parentName:"h2",href:"https://fastapi.tiangolo.com/"},"FastAPI")),(0,i.yg)("h3",{id:"advantages"},"Advantages"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"automatic documentation: OpenAPI, Swagger"),(0,i.yg)("li",{parentName:"ul"},"data validation, type hints: Python\u2019s type annotations and ",(0,i.yg)("a",{parentName:"li",href:"https://docs.pydantic.dev/latest/"},"Pydantic")," for data validation"),(0,i.yg)("li",{parentName:"ul"},"built-in support for dependency injection, which is useful for managing database\nsessions, authentication, and configuration"),(0,i.yg)("li",{parentName:"ul"},"websocket and background task support - can be helpful for real-time updates or long-running processes (for usages stats?)"),(0,i.yg)("li",{parentName:"ul"},"good ecosystem, community"),(0,i.yg)("li",{parentName:"ul"},"async support"),(0,i.yg)("li",{parentName:"ul"},"performance"),(0,i.yg)("li",{parentName:"ul"},"filtering, searching, pagination should be more easier to do")),(0,i.yg)("h3",{id:"disadvantages-from-our-architecture-discussion"},"Disadvantages (from our architecture discussion)"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"frequent updates, maintenance overhead"),(0,i.yg)("li",{parentName:"ul"},"Pydantic v2 Rust dependency: Pydantic v2 requires a Rust toolchain, which can be difficult to manage\non LTS-based distributions. Since we use Fedora-based images in OpenShift and can also pin dependencies,\nthis is unlikely to be a major blocker.")),(0,i.yg)("h3",{id:"considerations"},"Considerations"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"migration cost: refactoring, creating the models for documentation, rewriting of endpoints"),(0,i.yg)("li",{parentName:"ul"},"benefits:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"we could get rid of non-used endpoints"),(0,i.yg)("li",{parentName:"ul"},"we could refactor/improve the functionality"),(0,i.yg)("li",{parentName:"ul"},"documentation of endpoints => easier dashboard development"))),(0,i.yg)("li",{parentName:"ul"},"alternatives:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Sanic, Tornado, Falcon - lacking the functionalities such as validation, autodocumentation"),(0,i.yg)("li",{parentName:"ul"},"Django - too heavy"),(0,i.yg)("li",{parentName:"ul"},"none offer significant advantages over FastAPI/Flask")))),(0,i.yg)("h2",{id:"migration-requirements"},"Migration requirements"),(0,i.yg)("h3",{id:"rewriting-endpoints"},"Rewriting endpoints"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"convert Flask routes to FastAPI - replace Flask routes (",(0,i.yg)("inlineCode",{parentName:"li"},"@app.route"),") with FastAPI routes (",(0,i.yg)("inlineCode",{parentName:"li"},"@app.get()"),")."),(0,i.yg)("li",{parentName:"ul"},"update request parsing, query params"),(0,i.yg)("li",{parentName:"ul"},"response handling",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Pydantic models are recommended for response validation (raw dictionary responses can be returned also)"))),(0,i.yg)("li",{parentName:"ul"},"revisit error handling, utilise built-in support")),(0,i.yg)("h3",{id:"implementing-models"},"Implementing models"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"this is not strictly required (for the GET requests) but significantly improves the migration's value and is highly recommended."),(0,i.yg)("li",{parentName:"ul"},"it would be also our primary reason for migration:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"could be fixed in Flask, but the effort would be similar to a full migration"),(0,i.yg)("li",{parentName:"ul"},"previous attempt to document the endpoints with Flask:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/packit/packit-service/pull/2089/files"},"https://github.com/packit/packit-service/pull/2089/files")),(0,i.yg)("li",{parentName:"ul"},"the biggest issues: lot of duplication and additional code, change in serialization")))))),(0,i.yg)("h4",{id:"using-pydantic-with-our-existing-models"},"Using Pydantic with our existing models"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"retain current SQLAlchemy models for database interactions and add separate Pydantic schemas\nto handle API validation, serialization, and documentation"),(0,i.yg)("li",{parentName:"ul"},"support for integration with ORMs: ",(0,i.yg)("a",{parentName:"li",href:"https://docs.pydantic.dev/latest/concepts/models/#arbitrary-class-instances"},"https://docs.pydantic.dev/latest/concepts/models/#arbitrary-class-instances"))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from pydantic import BaseModel, ConfigDict\n\nclass UserSchema(BaseModel):\n    id: int\n    name: str\n    email: str\n\n    model_config = ConfigDict(from_attributes=True)\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"advantages:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"lower risk of breaking something: wouldn't need to touch the DB layer"),(0,i.yg)("li",{parentName:"ul"},"separation: DB layer decoupled from the API layer - control on what gets exposed via the API without altering the persistence logic"),(0,i.yg)("li",{parentName:"ul"},"flexibility: schema can be updated independently"))),(0,i.yg)("li",{parentName:"ul"},"disadvantages:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"duplication"),(0,i.yg)("li",{parentName:"ul"},"manual mapping")))),(0,i.yg)("h4",{id:"migrating-to-sqlmodel"},"Migrating to ",(0,i.yg)("a",{parentName:"h4",href:"https://sqlmodel.tiangolo.com/"},"SQLModel")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"a single model that serves both as database model and your API schema"),(0,i.yg)("li",{parentName:"ul"},"advantages:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"no duplication"),(0,i.yg)("li",{parentName:"ul"},"automatically validated and documented endpoints"),(0,i.yg)("li",{parentName:"ul"},"cleaner codebase"))),(0,i.yg)("li",{parentName:"ul"},"disadvantages:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"higher migration overhead: rewriting models, increased risk"),(0,i.yg)("li",{parentName:"ul"},"less mature: it is newer than the established combination of SQLAlchemy + Pydantic")))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from sqlmodel import SQLModel, Field\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    email: str\n\n")),(0,i.yg)("h2",{id:"migration-approach"},"Migration approach"),(0,i.yg)("h3",{id:"gradual-rewrite"},"Gradual rewrite"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"keep existing Flask endpoints and introduce FastAPI under e.g. ",(0,i.yg)("inlineCode",{parentName:"p"},"/api/v1/"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"migrate endpoints gradually (e.g., file by file) to FastAPI")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"update code to use the new endpoints")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"once all critical endpoints are migrated, remove Flask entirely")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"smaller risk of breaking something")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"work could be paralelised"))),(0,i.yg)("h3",{id:"rewrite-all-at-once"},"Rewrite all at once"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"requires rewriting all endpoints and models at once"),(0,i.yg)("li",{parentName:"ul"},"higher risk of introducing breaking changes")),(0,i.yg)("h2",{id:"migration-example"},"Migration example"),(0,i.yg)("h3",{id:"before"},"Before"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'koji_builds_ns = Namespace("koji-builds", description="Production builds")\n\n@koji_builds_ns.route("")\nclass KojiBuildsList(Resource):\n    @koji_builds_ns.expect(pagination_arguments)\n    @koji_builds_ns.response(HTTPStatus.PARTIAL_CONTENT, "Koji builds list follows")\n    def get(self):\n        """List all Koji builds."""\n        scratch = (\n            request.args.get("scratch").lower() == "true" if "scratch" in request.args else None\n        )\n        first, last = indices()\n        result = []\n\n        for build in KojiBuildTargetModel.get_range(first, last, scratch):\n            build_dict = {\n                "packit_id": build.id,\n                "task_id": build.task_id,\n                "scratch": build.scratch,\n                "status": build.status,\n                "build_submitted_time": optional_timestamp(build.build_submitted_time),\n                "chroot": build.target,\n                "web_url": build.web_url,\n                # from old data, sometimes build_logs_url is same and sometimes different to web_url\n                "build_logs_urls": build.build_logs_urls,\n                "pr_id": build.get_pr_id(),\n                "branch_name": build.get_branch_name(),\n                "release": build.get_release_tag(),\n            }\n\n            if project := build.get_project():\n                build_dict["project_url"] = project.project_url\n                build_dict["repo_namespace"] = project.namespace\n                build_dict["repo_name"] = project.repo_name\n\n            result.append(build_dict)\n\n        resp = response_maker(\n            result,\n            status=HTTPStatus.PARTIAL_CONTENT,\n        )\n        resp.headers["Content-Range"] = f"koji-builds {first + 1}-{last}/*"\n        return resp\n')),(0,i.yg)("h3",{id:"after-using-pydantic"},"After (using Pydantic)"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'from fastapi import APIRouter, Query, Request, Response, HTTPException\nfrom typing import List, Optional\nfrom pydantic import BaseModel\nfrom http import HTTPStatus\n\nrouter = APIRouter(prefix="/koji-builds", tags=["Production builds"])\n\n# Pydantic models\nclass ProjectModel(BaseModel):\n    project_url: str\n    repo_namespace: str\n    repo_name: str\n\n\nclass KojiBuildModel(BaseModel):\n    packit_id: int\n    task_id: int\n    scratch: bool\n    status: str\n    build_submitted_time: Optional[str]\n    chroot: str\n    web_url: str\n    build_logs_urls: List[str]\n    pr_id: Optional[int]\n    branch_name: Optional[str]\n    release: Optional[str]\n    project: Optional[ProjectModel] = None\n\n\n@router.get("", response_model=List[KojiBuildModel], status_code=HTTPStatus.PARTIAL_CONTENT)\ndef get_koji_builds(\n    request: Request,\n    response: Response,\n    scratch: Optional[bool] = Query(None, description="Filter by scratch builds"),\n    first: int = Query(0, description="Pagination start index"),\n    last: int = Query(10, description="Pagination end index"),\n):\n    """List all Koji builds."""\n    result = []\n\n    for build in KojiBuildTargetModel.get_range(first, last, scratch):\n        build_data = KojiBuildModel(\n            packit_id=build.id,\n            task_id=build.task_id,\n            scratch=build.scratch,\n            status=build.status,\n            build_submitted_time=optional_timestamp(build.build_submitted_time),\n            chroot=build.target,\n            web_url=build.web_url,\n            build_logs_urls=build.build_logs_urls,\n            pr_id=build.get_pr_id(),\n            branch_name=build.get_branch_name(),\n            release=build.get_release_tag(),\n            project=(\n                ProjectModel(\n                    project_url=build.get_project().project_url,\n                    repo_namespace=build.get_project().namespace,\n                    repo_name=build.get_project().repo_name,\n                )\n                if build.get_project()\n                else None\n            ),\n        )\n\n        result.append(build_data.model_dump())\n\n    response.headers["Content-Range"] = f"koji-builds {first + 1}-{last}/*"\n    return result\n\n\n')),(0,i.yg)("h3",{id:"useful-links"},"Useful links"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://testdriven.io/blog/moving-from-flask-to-fastapi/"},"https://testdriven.io/blog/moving-from-flask-to-fastapi/")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://amitness.com/posts/fastapi-vs-flask#data-validation"},"https://amitness.com/posts/fastapi-vs-flask#data-validation"))))}c.isMDXComponent=!0}}]);