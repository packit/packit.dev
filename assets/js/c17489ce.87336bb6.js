"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[391],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),s=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=s(a),k=i,m=d["".concat(l,".").concat(k)]||d[k]||u[k]||o;return a?n.createElement(m,p(p({ref:t},c),{},{components:a})):n.createElement(m,p({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,p=new Array(o);p[0]=k;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[d]="string"==typeof e?e:i,p[1]=r;for(var s=2;s<o;s++)p[s]=a[s];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},99358:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>p,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>s});var n=a(87462),i=(a(67294),a(3905));const o={title:"Monorepos",authors:"csomh"},p=void 0,r={unversionedId:"monorepo-support/index",id:"monorepo-support/index",title:"Monorepos",description:"Monorepos store the source code of multiple projects in a single repository.",source:"@site/research/monorepo-support/index.md",sourceDirName:"monorepo-support",slug:"/monorepo-support/",permalink:"/research/monorepo-support/",draft:!1,editUrl:"https://github.com/packit/research/tree/main/research/monorepo-support/index.md",tags:[],version:"current",frontMatter:{title:"Monorepos",authors:"csomh"},sidebar:"autogenerated",previous:{title:"Metrics",permalink:"/research/monitoring/metrics"},next:{title:"Code refactoring",permalink:"/research/monorepo-support/refactoring"}},l={},s=[{value:"<code>package.paths</code> and subdirectories to react on",id:"packagepaths-and-subdirectories-to-react-on",level:2},{value:"<code>package.paths</code> and working directories",id:"packagepaths-and-working-directories",level:2},{value:"Packages and specfile discovery",id:"packages-and-specfile-discovery",level:2},{value:"Impact on Source-git",id:"impact-on-source-git",level:2},{value:"<code>packit source-git init</code>",id:"packit-source-git-init",level:3},{value:"<code>packit source-git update-dist-git</code>",id:"packit-source-git-update-dist-git",level:3},{value:"<code>packit source-git update-source-git</code>",id:"packit-source-git-update-source-git",level:3},{value:"<code>packit source-git status</code>",id:"packit-source-git-status",level:3},{value:"Hardly",id:"hardly",level:3},{value:"Impact on Packit",id:"impact-on-packit",level:2},{value:"packit init",id:"packit-init",level:3},{value:"packit srpm",id:"packit-srpm",level:3},{value:"packit copr-build",id:"packit-copr-build",level:3},{value:"packit local-build",id:"packit-local-build",level:3},{value:"packit build",id:"packit-build",level:3},{value:"packit propose-downstream",id:"packit-propose-downstream",level:3},{value:"packit sync-from-downstream",id:"packit-sync-from-downstream",level:3},{value:"packit create-update",id:"packit-create-update",level:3},{value:"packit push-updates",id:"packit-push-updates",level:3},{value:"packit status",id:"packit-status",level:3},{value:"packit validate-config",id:"packit-validate-config",level:3},{value:"packit prepare-sources",id:"packit-prepare-sources",level:3},{value:"Impact on Packit API",id:"impact-on-packit-api",level:2},{value:"Internal Design",id:"internal-design",level:3},{value:"Inheritance (Overriding) of Configuration Keys",id:"inheritance-overriding-of-configuration-keys",level:3},{value:"Impact on Actions",id:"impact-on-actions",level:3},{value:"Backwards Compatibility",id:"backwards-compatibility",level:2},{value:"Open Issues",id:"open-issues",level:2}],c={toc:s},d="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Monorepos store the source code of multiple projects in a single repository.\nThey are a special use-case from a source-git point of view, because an\nupstream monorepo maps to multiple dist-git repositories in the distribution."),(0,i.kt)("p",null,"One example for the above is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/llvm/llvm-project"},"LLVM")," from which code flows into multiple\ndist-git repositories in Fedora Linux."),(0,i.kt)("p",null,"Currently Packit maps an upstream repo to a single dist-git repo in the\ndistribution."),(0,i.kt)("p",null,"To change this, a mechanism to specify which path(s) in the monorepo to map to\nwhich dist-git repo in the distribution needs to be introduced."),(0,i.kt)("p",null,"This could be done by introducing a ",(0,i.kt)("inlineCode",{parentName:"p"},"packages")," key, to hold a dictionary of\n",(0,i.kt)("inlineCode",{parentName:"p"},"{package_name: package_object}"),". Package-objects would have keys identical\nto the current top-level keys in ",(0,i.kt)("inlineCode",{parentName:"p"},".packit.yaml")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"source-git.yaml"),"."),(0,i.kt)("p",null,"A package-object could also have a new ",(0,i.kt)("inlineCode",{parentName:"p"},"paths")," key which is a list of\npaths in the monorepo which map to the dist-git repo specified by\n",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name"),"."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name")," is not specified, it would be assumed that the\ndist-git repo is called ",(0,i.kt)("inlineCode",{parentName:"p"},"package_name"),"."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"package.paths")," is not defined, it defaults to the root of the monorepo,\nthat is to ",(0,i.kt)("inlineCode",{parentName:"p"},'paths: ["./"]'),". This probably implies that paths need to be\nexplicitly defined for each package."),(0,i.kt)("p",null,"When processing a package from a monorepo, Packit should operate within these\npaths, that is, limit patch generation from Git-history to these paths, and\nuse only these paths to create the source-tarballs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Table of Contents")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packagepaths-and-subdirectories-to-react-on"},(0,i.kt)("inlineCode",{parentName:"a"},"package.paths")," and subdirectories to react on")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packagepaths-and-working-directories"},(0,i.kt)("inlineCode",{parentName:"a"},"package.paths")," and working directories")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packages-and-specfile-discovery"},"Packages and specfile discovery")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impact-on-source-git"},"Impact on Source-git"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-source-git-init"},(0,i.kt)("inlineCode",{parentName:"a"},"packit source-git init"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-source-git-update-dist-git"},(0,i.kt)("inlineCode",{parentName:"a"},"packit source-git update-dist-git"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-source-git-update-source-git"},(0,i.kt)("inlineCode",{parentName:"a"},"packit source-git update-source-git"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-source-git-status"},(0,i.kt)("inlineCode",{parentName:"a"},"packit source-git status"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#hardly"},"Hardly")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impact-on-packit"},"Impact on Packit"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-init"},"packit init")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-srpm"},"packit srpm")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-copr-build"},"packit copr-build")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-local-build"},"packit local-build")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-build"},"packit build")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-propose-downstream"},"packit propose-downstream")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-sync-from-downstream"},"packit sync-from-downstream")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-create-update"},"packit create-update")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-push-updates"},"packit push-updates")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-status"},"packit status")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-validate-config"},"packit validate-config")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#packit-prepare-sources"},"packit prepare-sources")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impact-on-packit-api"},"Impact on Packit API"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#internal-design"},"Internal Design")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#inheritance-overriding-of-configuration-keys"},"Inheritance (Overriding) of Configuration Keys")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impact-on-actions"},"Impact on Actions")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#backwards-compatibility"},"Backwards Compatibility")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#open-issues"},"Open Issues"))),(0,i.kt)("h2",{id:"packagepaths-and-subdirectories-to-react-on"},(0,i.kt)("inlineCode",{parentName:"h2"},"package.paths")," and subdirectories to react on"),(0,i.kt)("p",null,"In the context of monorepos it becomes handy to be able to filter the events a\nservice or bot reacts to based in which paths of the monorepo the change\nhappened."),(0,i.kt)("p",null,"This is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"package.paths")," in the sense that it allows bots and\nservices to react to a broader (or different) list of paths than the ones\ndefined to belong to a package."),(0,i.kt)("p",null,"To support this a new ",(0,i.kt)("inlineCode",{parentName:"p"},"handle")," configuration key should be introduced with a\n",(0,i.kt)("inlineCode",{parentName:"p"},"paths")," sub-key."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"handle.paths")," can be defined on the top-level, in the package-level (although\nit's not going to be used by the CLI) and on the job-level, and it's inherited\nas other configuration keys."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"handle.paths")," extends the trigger config option of jobs, by limiting the\nvalidity of the trigger to the paths defined."),(0,i.kt)("p",null,"When the ",(0,i.kt)("inlineCode",{parentName:"p"},"packages")," key is used, jobs have their ",(0,i.kt)("inlineCode",{parentName:"p"},"handle.paths")," set to the\nlist of ",(0,i.kt)("inlineCode",{parentName:"p"},"package.paths")," of the packages to be handled by the job. If\n",(0,i.kt)("inlineCode",{parentName:"p"},"packages")," is not used, the default value is the path of the root of the Git\nrepo."),(0,i.kt)("p",null,"We could mimic the GitHub syntax here, and also provide ",(0,i.kt)("inlineCode",{parentName:"p"},"handle.ignore_paths"),"\nand the exclamation-mark syntax (",(0,i.kt)("inlineCode",{parentName:"p"},"handle.paths: [!exluded/path, included/path]"),")."),(0,i.kt)("p",null,"Providing ",(0,i.kt)("inlineCode",{parentName:"p"},"handle.ignore_paths")," would be interesting, b/c it could be used to\nignore certain paths for all the packages, by defining its values on the\ntop-level."),(0,i.kt)("p",null,"Note, that a top-level ",(0,i.kt)("inlineCode",{parentName:"p"},"handle.paths")," would be always overrode by a\n",(0,i.kt)("inlineCode",{parentName:"p"},"package.paths"),". A ",(0,i.kt)("inlineCode",{parentName:"p"},"!flatten")," tag would come handy here, too, to allow to use\nreferences to combine lists in YAML."),(0,i.kt)("p",null,"Introducing ",(0,i.kt)("inlineCode",{parentName:"p"},"handle.paths")," would be independent of introducing ",(0,i.kt)("inlineCode",{parentName:"p"},"packages"),"\n(monorepo support), as it can be useful even without that, in fact ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/packit/packit-service/issues/545"},"it was\nrequested")," some long time ago."),(0,i.kt)("p",null,"For an example see the ",(0,i.kt)("a",{parentName:"p",href:"#impact-on-packit"},"Impact on Packit")," chapter below."),(0,i.kt)("h2",{id:"packagepaths-and-working-directories"},(0,i.kt)("inlineCode",{parentName:"h2"},"package.paths")," and working directories"),(0,i.kt)("p",null,"It's still not clear if having a ",(0,i.kt)("inlineCode",{parentName:"p"},"working_dir")," configuration value to set a\ncustom working directory would be strictly required for monorepo support.\nUser-defined actions can always ",(0,i.kt)("inlineCode",{parentName:"p"},"cd")," to the sub-directory of their liking. As\nfor default actions, it's less complicated if they all run from the root of\nthe Git repository."),(0,i.kt)("h2",{id:"packages-and-specfile-discovery"},"Packages and specfile discovery"),(0,i.kt)("p",null,"Without ",(0,i.kt)("inlineCode",{parentName:"p"},"packages"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"specfile_path"),", if defined."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"<downstream_package_name>.spec"),", if ",(0,i.kt)("inlineCode",{parentName:"li"},"downstream_package_name")," set."),(0,i.kt)("li",{parentName:"ol"},"Recursively search the Git repository.")),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"packages"),", for each package:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"specfile_path"),", if defined."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"<downstream_package_name>.spec")," in all the ",(0,i.kt)("inlineCode",{parentName:"li"},"paths"),", either because\n",(0,i.kt)("inlineCode",{parentName:"li"},"downstream_package_name")," is defined for the package, or because it\ndefaults to the name of the package."),(0,i.kt)("li",{parentName:"ol"},"Recursively search all the ",(0,i.kt)("inlineCode",{parentName:"li"},"paths")," of the package.")),(0,i.kt)("p",null,"Both in the case of 2. and 3. ",(0,i.kt)("inlineCode",{parentName:"p"},"paths")," are searched in the order in which they\nare defined in the configuration file."),(0,i.kt)("h2",{id:"impact-on-source-git"},"Impact on Source-git"),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"upstream_project_url: https://github.com/llvm/llvm-project.git\nupstream_ref: llvmorg-13.0.0-rc3\npackages:\n  lit:\n    downstream_package_name: python-lit\n    specfile_path: .distro/python-lit/python-lit.spec\n    paths:\n      - llvm/utils/lit\n    # This could be also used, but it's not required here.\n    # patch_generation_ignore_paths:\n    # - .distro\n    sync_changelog: true\n    files_to_sync:\n      - src: .distro/python-lit/\n        dest: .\n        delete: true\n        filters:\n          - protect .git*\n          - protect sources\n          - exclude .gitignore\n    sources:\n      - path: lit-13.0.0rc1\n        url: https://src.fedoraproject.org/repo/pkgs/rpms/python-lit/lit-13.0.0rc1/sha512/000a6875d371793ccab7f9c7af0e5906d1d98bb8ff09b297b7f0978c083ec05acb48fd8dbd1647bc9ba6548c8c629cc693219ce8d247877eab14ff250e46cfed/lit-13.0.0rc1\n")),(0,i.kt)("p",null,"With the above source-git configuration could be kept in\n",(0,i.kt)("inlineCode",{parentName:"p"},".distro/source-git.yaml"),". Downstream files to be synced to dist-git are to be\nkept in subdirectories, named according to ",(0,i.kt)("inlineCode",{parentName:"p"},"package_name")," (the key used in\n",(0,i.kt)("inlineCode",{parentName:"p"},"source-git.yaml")," to reference the package), in ",(0,i.kt)("inlineCode",{parentName:"p"},".distro"),", to keep things\norganized."),(0,i.kt)("p",null,"An example layout:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},".distro\n\u251c\u2500\u2500 backend\n\u2502   \u2514\u2500\u2500 copr-backend.spec\n\u251c\u2500\u2500 cli\n\u2502   \u2514\u2500\u2500 copr-cli.spec\n\u251c\u2500\u2500 frontend\n\u2502   \u2514\u2500\u2500 copr-frontend.spec\n\u2514\u2500\u2500 source-git.yaml\n")),(0,i.kt)("p",null,"This way all distribution configs and files would be kept at one place, which\nprobably is somewhat better than having source-git configuration spread across\nthe monorepo, in different subdirectories. This setup also allows multiple\npaths from the repo mapped to a signle dist-git repo."),(0,i.kt)("h3",{id:"packit-source-git-init"},(0,i.kt)("inlineCode",{parentName:"h3"},"packit source-git init")),(0,i.kt)("p",null,"If the source-git repository to be initialized is a monorepo, then each\ndist-git repository specified will also need to one or more subdirectories of\nthe source-git repository."),(0,i.kt)("p",null,"Which makes the whole thing a little bit too complicated \u263a"),(0,i.kt)("p",null,"This complication could be elevated, if ",(0,i.kt)("inlineCode",{parentName:"p"},"packit source-git init")," would use a\nguided (dialog-like) process, instead of taking all its inputs as arguments."),(0,i.kt)("p",null,"As an alternative, the command could have a variant where it takes a basic\n",(0,i.kt)("inlineCode",{parentName:"p"},"packages")," definition to guide the initialization of a source-git monorepo."),(0,i.kt)("p",null,"Example ",(0,i.kt)("inlineCode",{parentName:"p"},"packages.yaml"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"- downstream_package_name: copr-backend\n  path: backend\n  dist_git_path: rpms/copr-backend\n  dist_git_branch: rawhide\n- downstream_package_name: copr-frontend\n  path: frontend\n  dist_git_path: rpms/copr-frontend\n  dist_git_branch: rawhide\n- downstream_package_name: copr-cli\n  path: cli\n  dist_git_path: rpms/copr-cli\n  dist_git_branch: rawhide\n")),(0,i.kt)("p",null,"Which could be used as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"$ packit source-git init --packages packages.yaml v3.0.0 src/copr\n")),(0,i.kt)("p",null,"Or the same could be read from STDIN, with ",(0,i.kt)("inlineCode",{parentName:"p"},"--packages=-"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"$ packit source-git init --packages=- v3.0.0 src/copr\n")),(0,i.kt)("p",null,"Given that setting up a source-git repository is expected to be a one-time\nactivity, and that there are not so many projects which are monorepos,\nimplementing the above should probably have ",(0,i.kt)("strong",{parentName:"p"},"a low priority for now"),"."),(0,i.kt)("h3",{id:"packit-source-git-update-dist-git"},(0,i.kt)("inlineCode",{parentName:"h3"},"packit source-git update-dist-git")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"At a minimum"),", the command should be updated to support monorepos, and\ntransform only the content specific to the package from source-git. The\npackage name (",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name"),") to be considered from\n",(0,i.kt)("inlineCode",{parentName:"p"},".distro/source-git.yaml")," is the one which matches ",(0,i.kt)("inlineCode",{parentName:"p"},"basename DIST_GIT"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Going further"),", when used with monorepos, this command could be able to\nupdate multiple dist-git repositories. This means, that the ",(0,i.kt)("inlineCode",{parentName:"p"},"DIST_GIT"),"\nargument of the command would become ",(0,i.kt)("inlineCode",{parentName:"p"},"DIST_GIT [DIST_GIT...]")," (one or more\npaths to dist-git repositories)."),(0,i.kt)("p",null,"In the form above, the command would update only the dist-git repositories\nwhich are specified on the command line. If any of the ",(0,i.kt)("inlineCode",{parentName:"p"},"DIST_GIT")," arguments\nspecified is not a ",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name")," in ",(0,i.kt)("inlineCode",{parentName:"p"},".distro/source-git.yaml"),", the\ncommand would fail. This would be an early check, before any other change is\ndone."),(0,i.kt)("p",null,"An alternative form of the command could allow updating multiple dist-git\nrepositories found in ",(0,i.kt)("inlineCode",{parentName:"p"},"--dist-git-store"),". The command would figure out\ndist-git subdirectory names in ",(0,i.kt)("inlineCode",{parentName:"p"},"--dist-git-store"),", based on\n",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name"),"s found in ",(0,i.kt)("inlineCode",{parentName:"p"},".distro/source-git.yaml"),". If any of them\nis missing, the command would fail early."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"SYNOPSIS\n       packit source-git update-dist-git [OPTIONS] --dist-git-store PATH SOURCE_GIT\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"$ packit source-git update-dist-git --dist-git-store rpms/ src/copr\n")),(0,i.kt)("h3",{id:"packit-source-git-update-source-git"},(0,i.kt)("inlineCode",{parentName:"h3"},"packit source-git update-source-git")),(0,i.kt)("p",null,"Let's not change the interface of this command and don't support the usecase\nto update a single source-git monorepo from multiple dist-git repositories in\norder to avoid complications. Expect that multiple commands are going to be\nexecuted if updates need to be taken from multiple dist-git repositories."),(0,i.kt)("p",null,"On the other hand, the command needs to be updated to support a source-git\nrepo as a target when the source-git repo is a monorepo. In this case only the\npaths of the sub-package need to be considered during the update. ",(0,i.kt)("inlineCode",{parentName:"p"},"DIST_GIT"),"\nshould match one of the ",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name"),"s in ",(0,i.kt)("inlineCode",{parentName:"p"},".distro/source-git.yaml"),"."),(0,i.kt)("h3",{id:"packit-source-git-status"},(0,i.kt)("inlineCode",{parentName:"h3"},"packit source-git status")),(0,i.kt)("p",null,"The command should check the sync status of a sub-package from a source-git\nmonorepo and the corresponding dist-git repo. ",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name")," should\nmatch ",(0,i.kt)("inlineCode",{parentName:"p"},"basename DIST_GIT"),"."),(0,i.kt)("h3",{id:"hardly"},"Hardly"),(0,i.kt)("p",null,"When opening an MR in a source-git monorepo, Hardly should figure out which\ndist-git packages are going to be impacted by the change (by looking at\n",(0,i.kt)("inlineCode",{parentName:"p"},"package.paths"),"), and open mirror-MRs in the dist-git repositories of those\npackages."),(0,i.kt)("p",null,"CI results from all mirror-MRs should be synced back to the source-git MR."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question"),": Is the behavior above good enough? Can there be source-git\nchanges happening outside the package paths, but which influence the dist-git\ncontent of the package?"),(0,i.kt)("h2",{id:"impact-on-packit"},"Impact on Packit"),(0,i.kt)("p",null,"All things that follow assume that ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/packit/packit/issues/1515"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"metadata")," key was dropped"),"."),(0,i.kt)("p",null,"Additionally to what was presented above, a new property of job-objects in\n",(0,i.kt)("inlineCode",{parentName:"p"},".packit.yaml")," needs to be introduced, to be used to specify which packages\nthe job should handle when triggered. The property would be called ",(0,i.kt)("inlineCode",{parentName:"p"},"packages"),"\nand would be a list of package-object names. If a job-object has no such key,\nall packages of a monorepo should be handled."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"handle:\n  ignore_paths:\n    - doc\nupstream_project_url: https://pagure.io/copr/copr.git\npackages:\n  copr-backend:\n    # defining 'specfile_path' would be optional\n    specfile_path: backend/copr-backend.spec\n    paths:\n      - backend\n  copr-frontend:\n    specfile_path: frontend/copr-frontend.spec\n    paths:\n      - frontend\n  copr-cli:\n    specfile_path: cli/copr-cli.spec\n    paths:\n      - cli\njobs:\n  - job: copr_build\n    trigger: pull_request\n    targets:\n      - fedora-all\n      - epel-8\n    packages:\n      - copr-frontend\n      - copr-backend\n    handle:\n      paths:\n        - backend\n        - frontend\n        - common\n  - job: copr_build\n    trigger: pull_request\n    targets:\n      - fedora-all\n    packages:\n      - copr-cli\n    handle:\n      paths:\n        - cli\n        - common\n")),(0,i.kt)("h3",{id:"packit-init"},"packit init"),(0,i.kt)("p",null,"No changes are required for this command. ",(0,i.kt)("inlineCode",{parentName:"p"},".packit.yaml")," is expected to be\ncrafted manually if the upstream repository is a monorepo."),(0,i.kt)("h3",{id:"packit-srpm"},"packit srpm"),(0,i.kt)("p",null,"The command should receive a new optional argument, ",(0,i.kt)("inlineCode",{parentName:"p"},"[PACKAGE...]"),", to define\nzero or more packages for which an SRPM should be built."),(0,i.kt)("p",null,"If no such argument is present, an SRPM should be produced for all packages\ndefined in ",(0,i.kt)("inlineCode",{parentName:"p"},".packit.yaml"),". When one or more such arguments are present, and\nSRPM should be produced only for the packages specified."),(0,i.kt)("p",null,"The command should fail if any of the ",(0,i.kt)("inlineCode",{parentName:"p"},"PACKAGE")," argument has no corresponding\n",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name")," in ",(0,i.kt)("inlineCode",{parentName:"p"},".packit.yaml"),"."),(0,i.kt)("p",null,"When a ",(0,i.kt)("inlineCode",{parentName:"p"},"PACKAGE")," argument is used ",(0,i.kt)("inlineCode",{parentName:"p"},"PATH_OR_URL")," is expected to be explicitly\nprovided. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"$ pwd\n/home/user/src/copr\n$ packit srpm . backend\n")),(0,i.kt)("h3",{id:"packit-copr-build"},"packit copr-build"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"packit srpm"),", the command should receive a new optional\n",(0,i.kt)("inlineCode",{parentName:"p"},"[PACKAGE...]")," argument, which should allow to trigger Copr-builds only to\nthose the packages specified."),(0,i.kt)("h3",{id:"packit-local-build"},"packit local-build"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"packit srpm"),"."),(0,i.kt)("h3",{id:"packit-build"},"packit build"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"packit srpm"),"."),(0,i.kt)("h3",{id:"packit-propose-downstream"},"packit propose-downstream"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"packit srpm"),". When a ",(0,i.kt)("inlineCode",{parentName:"p"},"PACKAGE")," argument is specified updates are\nproposed only for those packages, and specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"PATH_OR_URL")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"VERSION"),"\nbecomes mandatory."),(0,i.kt)("h3",{id:"packit-sync-from-downstream"},"packit sync-from-downstream"),(0,i.kt)("p",null,"This is copying synced files from downstream to upstream."),(0,i.kt)("p",null,"The command needs to support the same ",(0,i.kt)("inlineCode",{parentName:"p"},"[PACKAGE...]")," argument as\n",(0,i.kt)("inlineCode",{parentName:"p"},"packit srpm"),", and sync from only the specified dist-git repositories, when at\nleast on of such an arguments is specified."),(0,i.kt)("h3",{id:"packit-create-update"},"packit create-update"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"packit srpm"),". When a ",(0,i.kt)("inlineCode",{parentName:"p"},"PACKAGE")," argument is specified updates are\ncreated only for the specified packages."),(0,i.kt)("p",null,"There should be ",(0,i.kt)("strong",{parentName:"p"},"one update created"),", including all (or the specified\nsubset) of packages (packages from a monorepo are usually ",(0,i.kt)("a",{parentName:"p",href:"https://bodhi.fedoraproject.org/updates/FEDORA-2022-8f02fc9461"},"released as a batch"),")."),(0,i.kt)("h3",{id:"packit-push-updates"},"packit push-updates"),(0,i.kt)("p",null,"This command works with updates. Currently if no option is provided updates\nwhich are in testing and belong to the package are pushed."),(0,i.kt)("p",null,"In a monorepo, if no argument is provided, all updates in testing which\ncontain any of the packages in the monorepo should be pushed."),(0,i.kt)("p",null,"If one or more ",(0,i.kt)("inlineCode",{parentName:"p"},"PACKAGES")," are specified, all updates in testing which could be\npushed and contain any of the packages specified should be pushed."),(0,i.kt)("h3",{id:"packit-status"},"packit status"),(0,i.kt)("p",null,"The command should display status for all packages in a monorepo, or if one\nmore ",(0,i.kt)("inlineCode",{parentName:"p"},"PACKAGES")," are specified, status should be displayed for those packages."),(0,i.kt)("h3",{id:"packit-validate-config"},"packit validate-config"),(0,i.kt)("p",null,"Check if the paths specified in ",(0,i.kt)("inlineCode",{parentName:"p"},"package.paths")," do exist in the monorepo."),(0,i.kt)("p",null,"Check if the package names (",(0,i.kt)("inlineCode",{parentName:"p"},"downstream_package_name"),") are correct and indeed\nexist in the distribution. See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/packit/packit/issues/88"},"packit/packit#88"),"."),(0,i.kt)("h3",{id:"packit-prepare-sources"},"packit prepare-sources"),(0,i.kt)("p",null,"The command should be updated similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"packit srpm"),", so that it's possible\nto limit changes only to select packages."),(0,i.kt)("h2",{id:"impact-on-packit-api"},"Impact on Packit API"),(0,i.kt)("h3",{id:"internal-design"},"Internal Design"),(0,i.kt)("p",null,"With monorepos needs to be taught to map a single upstream repository\n(",(0,i.kt)("inlineCode",{parentName:"p"},"PackitAPI.up"),") to multiple dist-git/downstream repositories. This means that\n",(0,i.kt)("inlineCode",{parentName:"p"},"PackitAPI.dg")," should become a dictionary holding the objects for each\ndist-git repository."),(0,i.kt)("p",null,"In order to make the transition easier, we could keep ",(0,i.kt)("inlineCode",{parentName:"p"},".dg")," as it is, and make\nit to return the dist-git repo for the first (and only) package. If there are\nmore packages defined, an exception should be raised. This way parts of the\nAPI and CLI which were not yet updated to support monorepos, could continue to\nwork, but would fail if used with a monorepo configuration specifying multiple\npackages."),(0,i.kt)("h3",{id:"inheritance-overriding-of-configuration-keys"},"Inheritance (Overriding) of Configuration Keys"),(0,i.kt)("p",null,"One can override configuration defined on the top-level of ",(0,i.kt)("inlineCode",{parentName:"p"},".packit.yaml")," in a\npackage-object. That is, all top-level values are inherited by package-objects."),(0,i.kt)("p",null,"Configuration values can be further overridden in job objects, but only for\nthe packages the job references (if any.)"),(0,i.kt)("mermaid",{value:"flowchart BT\n    C(Job) --\x3e B(Package)\n    B --\x3e A(Top-level)"}),(0,i.kt)("p",null,"A (not very meaningful) example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"srpm_build_deps:\n  - python3-pip\n  - python3-setuptools\npackages:\n  subpackage1:\n    paths:\n      - package1\n    srpm_build_deps:\n      - python3-pip\n      - python3-setuptools\n      - python3-packaging\n  subpackage2:\n    paths:\n      - package2\njobs:\n  - job: copr_build\n    trigger: pull_request\n    srpm_build_deps:\n      - python3-pip\n      - python3-setuptools\n      - cowsay\n    targets:\n      - fedora-all\n  - job: copr_build\n    trigger: release\n    packages:\n      - subpackage1\n    targets:\n      - fedora-all\n      - epel-9\n")),(0,i.kt)("p",null,"In the example above when building PRs in Copr, the ",(0,i.kt)("inlineCode",{parentName:"p"},"srpm_build_deps")," defined\nin the job would be used for both packages."),(0,i.kt)("p",null,"On the other hand, when building releases in Copr, only ",(0,i.kt)("inlineCode",{parentName:"p"},"subpackage1")," is going\nto be built, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"srpm_build_deps")," will be the ones defined for the\npackage in the ",(0,i.kt)("inlineCode",{parentName:"p"},"packages")," section."),(0,i.kt)("p",null,"The example above could be made more useful if extending lists would be\nsupported by Packit. (YAML doesn't support this, one gets nested lists when\nusing references in lists.)"),(0,i.kt)("h3",{id:"impact-on-actions"},"Impact on Actions"),(0,i.kt)("p",null,"Because actions can now be defined on the top-level, package-level and\njob-level, one might ask, in what path these should be executed."),(0,i.kt)("p",null,"Because a package can map to multiple sub-paths in the monorepo, the most\nsensible thing to do is to keep it simple and execute each action at the\ntop-level, even if the action is defined on a job- or package-level. If\nneeded, user-defined actions can still ",(0,i.kt)("inlineCode",{parentName:"p"},"cd")," into a preferred sub-directory."),(0,i.kt)("h2",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,i.kt)("p",null,"For backwards compatibility: if the top-level ",(0,i.kt)("inlineCode",{parentName:"p"},"packages")," key is missing,\nsource-git configuration is read as currently is."),(0,i.kt)("h2",{id:"open-issues"},"Open Issues"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"TODO Can archives stored in the dist-git repositories mapped to one or more\npaths in the upstream repo?"),(0,i.kt)("li",{parentName:"ul"},"TODO Is support needed to have different packages generated from different\ngit refs? (This would defy the point in having a monorepo, but some might\nrequire it, for example ",(0,i.kt)("a",{parentName:"li",href:"https://pagure.io/copr/copr"},"Copr"),".)")))}u.isMDXComponent=!0}}]);