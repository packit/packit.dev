"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[747],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>d});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(r),u=a,d=m["".concat(l,".").concat(u)]||m[u]||h[u]||o;return r?n.createElement(d,i(i({ref:t},p),{},{components:r})):n.createElement(d,i({ref:t},p))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},91446:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=r(87462),a=(r(67294),r(3905));const o={title:"Pull fixes from the upstream",date:new Date("2021-01-26T22:59:59.000Z"),sidebar_position:20},i="Pull fixes from the upstream",s={unversionedId:"work-with-source-git/pull-upstream-fixes",id:"work-with-source-git/pull-upstream-fixes",title:"Pull fixes from the upstream",description:"One of the common tasks of being a downstream maintainer is to pull fixes from",source:"@site/source-git/work-with-source-git/pull-upstream-fixes.md",sourceDirName:"work-with-source-git",slug:"/work-with-source-git/pull-upstream-fixes",permalink:"/source-git/work-with-source-git/pull-upstream-fixes",draft:!1,editUrl:"https://github.com/packit/packit.dev/tree/main/source-git/work-with-source-git/pull-upstream-fixes.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"Pull fixes from the upstream",date:"2021-01-26T22:59:59.000Z",sidebar_position:20},sidebar:"autogenerated",previous:{title:"Update a spec file",permalink:"/source-git/work-with-source-git/update-spec"},next:{title:"Controlling patch generation",permalink:"/source-git/work-with-source-git/control-patch-generation"}},l={},c=[{value:"Adding changes",id:"adding-changes",level:2},{value:"Controlling the patch process",id:"controlling-the-patch-process",level:3}],p={toc:c},m="wrapper";function h(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pull-fixes-from-the-upstream"},"Pull fixes from the upstream"),(0,a.kt)("p",null,"One of the common tasks of being a downstream maintainer is to pull fixes from\nthe upstream codebase. This usually happens when a problem is discovered\ndownstream which is already resolved in the upstream code. There are two\nscenarios how to obtain the upstream code:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The fix is not released yet by the upstream - this implies pulling the fix\nfrom the main development upstream branch."),(0,a.kt)("li",{parentName:"ol"},"If the fix is already released, one can either update to that upstream\nrelease or only pull commits with the fix. Please consult ",(0,a.kt)("a",{parentName:"li",href:"https://fedoraproject.org/wiki/Updates_Policy#Stable_Releases"},"Fedora Update Policy\n")," if\nyou are unsure how to proceed.")),(0,a.kt)("h2",{id:"adding-changes"},"Adding changes"),(0,a.kt)("p",null,"Since your source-git repository shares git history with upstream, you can\neasily cherry-pick commits which you want to have in the downstream and Packit\nis then able to turn those commits into patch files with the ability to\nconfigure the whole process."),(0,a.kt)("p",null,"As an example, let's try to do this with systemd, in the example below we'd be\nusing ",(0,a.kt)("a",{parentName:"p",href:"https://gitlab.com/packit-service/src/systemd"},"https://gitlab.com/packit-service/src/systemd"),". The remote mimics how\n",(0,a.kt)("inlineCode",{parentName:"p"},"fedpkg fork")," works."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ git remote -v\norigin      git@gitlab.com:packit-service/src/systemd.git (push)\nttomecek    git@gitlab.com:TomasTomecek/systemd-stable.git (push)\nupstream    git@github.com:systemd/systemd-stable.git (push)\n")),(0,a.kt)("p",null,"We have 3 remotes in the repo:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"origin")," \u2014 the official source-git repo where the downstream maintenance happens"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"ttomecek")," \u2014 a fork of the source-git repo"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"upstream")," \u2014 the official upstream repository")),(0,a.kt)("p",null,"With this setup, we can fetch ref from the ",(0,a.kt)("inlineCode",{parentName:"p"},"upstream")," remote, cherry-pick commits\nof our choice, push them to the fork ",(0,a.kt)("inlineCode",{parentName:"p"},"ttomecek")," and open a merge request against the\nrepository referenced as the ",(0,a.kt)("inlineCode",{parentName:"p"},"origin")," remote."),(0,a.kt)("h3",{id:"controlling-the-patch-process"},"Controlling the patch process"),(0,a.kt)("p",null,"Packit recognizes that the upstream commits are meant to be downstream patches:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Packit generates patch files from the commits via ",(0,a.kt)("inlineCode",{parentName:"li"},"git format-patch"),"."),(0,a.kt)("li",{parentName:"ol"},"It also adds them into the spec file as new ",(0,a.kt)("inlineCode",{parentName:"li"},"PatchXYZ")," entries.")),(0,a.kt)("p",null,"If that doesn't work for you, you can tailor the patch process. The main\ndownside is that with the default process you cannot name the patch file nor\ncontrol where exactly should Packit place the ",(0,a.kt)("inlineCode",{parentName:"p"},"Patch123: 123.patch")," line in the\nspec file. There is a way though how you can have more control over the process.\nYou can add ",(0,a.kt)("a",{parentName:"p",href:"https://git-scm.com/docs/git-interpret-trailers"},"Git-trailers")," to the end of a commit message which Packit will\nthen read and take into account:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Patch-name")," \u2014 name of the patch (e.g. ",(0,a.kt)("inlineCode",{parentName:"li"},"Patch-name: my-fancy.patch"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Patch-id")," \u2014 numerical ID used in the patch-tag when adding the\npatch to the spec-file")),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"control-patch-generation"},"Controlling patch generation")," for detailed description of all trailers."),(0,a.kt)("p",null,"Example of a commit in a source-git repo:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Author:     Packit <packit>\nAuthorDate: Wed Aug 19 11:55:14 2020 +0000\nCommit:     Packit <packit>\nCommitDate: Wed Aug 19 11:55:14 2020 +0000\n\n    add workaround for gcc7 on ppc64le temporary before it's fixed in gcc\n\n    https://bugzilla.redhat.com/show_bug.cgi?id=1420350\n\n    Patch-name: drpm-0.3.0-workaround-ppc64le-gcc.patch\n    Patch-id: 100\n---\nsrc/CMakeLists.txt  |  2 +-\ntest/CMakeLists.txt | 12 +-----------\n2 files changed, 2 insertions(+), 12 deletions(-)\n")),(0,a.kt)("p",null,"And this is how a corresponding spec file looks (shortened for brevity)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Name:           drpm\nVersion:        0.4.1\nRelease:        2.g959639c5%{?dist}\nURL:            https://github.com/rpm-software-management/%{name}\nSource:         %{url}/releases/download/%{version}/%{name}-%{version}.tar.bz2\n\n# add workaround for gcc7 on ppc64le temporary before it's fixed in gcc\n# https://bugzilla.redhat.com/show_bug.cgi?id=1420350\nPatch100:       drpm-0.3.0-workaround-ppc64le-gcc.patch\n\n%prep\n%autosetup -p1\n")))}h.isMDXComponent=!0}}]);