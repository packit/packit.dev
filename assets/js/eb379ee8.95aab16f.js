"use strict";(self.webpackChunkpackit_dev=self.webpackChunkpackit_dev||[]).push([[79429],{15680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>d});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),g=i,d=m["".concat(s,".").concat(g)]||m[g]||u[g]||o;return n?a.createElement(d,r(r({ref:t},c),{},{components:n})):a.createElement(d,r({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},37223:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(58168),i=(n(96540),n(15680));const o={title:"Job cancelling",authors:"mfocko"},r=void 0,l={unversionedId:"ux/job-cancelling",id:"ux/job-cancelling",title:"Job cancelling",description:"- Original issue",source:"@site/research/ux/job-cancelling.md",sourceDirName:"ux",slug:"/ux/job-cancelling",permalink:"/research/ux/job-cancelling",draft:!1,editUrl:"https://github.com/packit/research/tree/main/research/ux/job-cancelling.md",tags:[],version:"current",frontMatter:{title:"Job cancelling",authors:"mfocko"},sidebar:"autogenerated",previous:{title:"Improve Packit Service event processing",permalink:"/research/ux/improve-service-processing"},next:{title:"Workflow engines",permalink:"/research/workflow-engines/"}},s={},p=[{value:"Motivation",id:"motivation",level:2},{value:"Finding the jobs to cancel",id:"finding-the-jobs-to-cancel",level:2},{value:"Triggered by commit / pull request",id:"triggered-by-commit--pull-request",level:3},{value:"Lookup based on the commit hash",id:"lookup-based-on-the-commit-hash",level:4},{value:"Alternative approach",id:"alternative-approach",level:4},{value:"Triggered by release",id:"triggered-by-release",level:3},{value:"Subsequent jobs",id:"subsequent-jobs",level:3},{value:"Cancelling the jobs themselves",id:"cancelling-the-jobs-themselves",level:2},{value:"Copr",id:"copr",level:3},{value:"Testing Farm",id:"testing-farm",level:3},{value:"Koji",id:"koji",level:3},{value:"VM Image Builder",id:"vm-image-builder",level:3},{value:"OpenScanHub",id:"openscanhub",level:3},{value:"Breakdown",id:"breakdown",level:2}],c={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(m,(0,a.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/packit/packit-service/issues/5"},"Original issue")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/packit/packit-service/issues/2694"},"Backing issue")))),(0,i.yg)("h2",{id:"motivation"},"Motivation"),(0,i.yg)("p",null,"Saving up resources of the external services (especially for projects running\nbuilds / tests for an extensive matrix of ",(0,i.yg)("em",{parentName:"p"},"architectures \xd7 releases \xd7 distros"),")."),(0,i.yg)("h2",{id:"finding-the-jobs-to-cancel"},"Finding the jobs to cancel"),(0,i.yg)("admonition",{type:"warning"},(0,i.yg)("p",{parentName:"admonition"},"We also have to consider subsequent jobs, i.e., running TF after Copr build\nsucceeds.")),(0,i.yg)("p",null,"We should differentiate here based on the trigger / event."),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"In general, when pushing to branches git forges usually provide previous commit\nhash, parse and provide it in the event, so that we can optimize the lookup\nin the database on our side.")),(0,i.yg)("h3",{id:"triggered-by-commit--pull-request"},"Triggered by commit / pull request"),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"In both cases we should be given previous commit hash.")),(0,i.yg)("p",null,"In the most ideal scenario, we should utilize the provided previous commit, to\nfind the latest pipeline that might be still running."),(0,i.yg)("admonition",{title:"Arch discussion",type:"note"},(0,i.yg)("p",{parentName:"admonition"},"Do not cancel builds/tests on commit trigger for now.")),(0,i.yg)("h4",{id:"lookup-based-on-the-commit-hash"},"Lookup based on the commit hash"),(0,i.yg)("admonition",{title:"Arch discussion",type:"note"},(0,i.yg)("p",{parentName:"admonition"},"Start with the cheapest approach, i.e., this one.")),(0,i.yg)("p",null,"Finding the latest pipeline that might be still running based on the commit hash\ncan be done by lookup through ",(0,i.yg)("inlineCode",{parentName:"p"},"PipelineModel")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"ProjectEventModel")," (provided\nvia ",(0,i.yg)("inlineCode",{parentName:"p"},"project_event_id"),") that has a commit hash attribute."),(0,i.yg)("h4",{id:"alternative-approach"},"Alternative approach"),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"Looks much simpler using the ORM, but boils down to the enumeration below\nanyways.")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Join on ",(0,i.yg)("inlineCode",{parentName:"li"},"pipelines \xd7 project events")),(0,i.yg)("li",{parentName:"ol"},"Filter by event type (commit or pull request)"),(0,i.yg)("li",{parentName:"ol"},"Join on ",(0,i.yg)("inlineCode",{parentName:"li"},"(pipelines \xd7 project events) \xd7 specific events")),(0,i.yg)("li",{parentName:"ol"},"And then find latest by",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"commit: branch"),(0,i.yg)("li",{parentName:"ul"},"pull request: PR ID")))),(0,i.yg)("h3",{id:"triggered-by-release"},"Triggered by release"),(0,i.yg)("p",null,"tl;dr ",(0,i.yg)("em",{parentName:"p"},"n/a")),(0,i.yg)("p",null,"Doesn't make sense to consider, since there is no reasonable scenario for\n",(0,i.yg)("em",{parentName:"p"},"re-releasing"),"."),(0,i.yg)("h3",{id:"subsequent-jobs"},"Subsequent jobs"),(0,i.yg)("p",null,"Given the pipelines we store, it shouldn't be hard, basically similar approach\nas for cancelling the initial job, just gotta check any other fields in the same\nrow."),(0,i.yg)("h2",{id:"cancelling-the-jobs-themselves"},"Cancelling the jobs themselves"),(0,i.yg)("p",null,"Given that we know what we want to cancel, it is relatively easy to execute with\nthe most critical services that we integrate (VM Image Builder is rather vague\nin the description of what ",(0,i.yg)("inlineCode",{parentName:"p"},"DELETE")," on a compose means and OpenScanHub has no\nmention of allowing to cancel running scans)."),(0,i.yg)("h3",{id:"copr"},"Copr"),(0,i.yg)("p",null,"With build ID it's possible to easily cancel the job via the following API call\non our side:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-py"},"# packit/copr_helper.py\nself.copr_client.build_proxy.cancel(build_id)\n")),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://python-copr.readthedocs.io/en/latest/client_v3/proxies.html#copr.v3.proxies.build.BuildProxy.cancel"},"Link to Copr docs")),(0,i.yg)("h3",{id:"testing-farm"},"Testing Farm"),(0,i.yg)("p",null,"TF has an ",(0,i.yg)("a",{parentName:"p",href:"https://api.testing-farm.io/redoc#operation/delete_test_request_v0_1_requests__request_id__delete"},"API endpoint")," for deleting the test requests:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"DELETE https://api.testing-farm.io/v0.1/requests/{request_id}\n")),(0,i.yg)("h3",{id:"koji"},"Koji"),(0,i.yg)("p",null,"There are multiple API calls:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"cancelling a specific build - ",(0,i.yg)("a",{parentName:"li",href:"https://koji.fedoraproject.org/koji/api#:~:text=cancelBuild(buildID%2C%20strict%3DFalse)"},(0,i.yg)("inlineCode",{parentName:"a"},"cancelBuild"))),(0,i.yg)("li",{parentName:"ul"},"cancelling a task - ",(0,i.yg)("a",{parentName:"li",href:"https://koji.fedoraproject.org/koji/api#:~:text=cancelTask(task_id%2C%20recurse%3DTrue)"},(0,i.yg)("inlineCode",{parentName:"a"},"cancelTask"))),(0,i.yg)("li",{parentName:"ul"},"cancelling a \u201cfull\u201d task - ",(0,i.yg)("a",{parentName:"li",href:"https://koji.fedoraproject.org/koji/api#:~:text=cancelTaskFull(task_id%2C%20strict%3DTrue)"},(0,i.yg)("inlineCode",{parentName:"a"},"cancelTaskFull")))),(0,i.yg)("admonition",{title:"Arch discussion",type:"note"},(0,i.yg)("p",{parentName:"admonition"},"Do not consider for now, but could be beneficial for saving resources of the\nFedora Infra once we run as a ",(0,i.yg)("em",{parentName:"p"},"Fedora CI"),".")),(0,i.yg)("h3",{id:"vm-image-builder"},"VM Image Builder"),(0,i.yg)("p",null,"It ",(0,i.yg)("strong",{parentName:"p"},"appears")," that it is possible to ",(0,i.yg)("em",{parentName:"p"},"delete")," a compose:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},'/composes/{composeId}:\n  delete:\n    description: |\n      Deletes a compose, the compose will still count towards quota.\n    operationId: deleteCompose\n    responses:\n      "200":\n        description: OK\n    summary: delete a compose\n  get:\n    description: status of an image compose\n    operationId: getComposeStatus\n    responses:\n      "200":\n        content:\n          application/json:\n            schema:\n              $ref: "#/components/schemas/ComposeStatus"\n        description: compose status\n    summary: get status of an image compose\n    tags:\n      - compose\n  parameters:\n    - description: Id of compose\n      in: path\n      name: composeId\n      required: true\n      schema:\n        example: 123e4567-e89b-12d3-a456-426655440000\n        format: uuid\n        type: string\n')),(0,i.yg)("p",null,"Though based on the description, as you can see, it still counts towards the\nquota and there's no mention that it would cancel running image build."),(0,i.yg)("h3",{id:"openscanhub"},"OpenScanHub"),(0,i.yg)("p",null,"Based on a brief look through the docs, it appears that it is not possible to\ncancel running scans."),(0,i.yg)("h2",{id:"breakdown"},"Breakdown"),(0,i.yg)("p",null,"Suggested splitting into subtasks:"),(0,i.yg)("ul",{className:"contains-task-list"},(0,i.yg)("li",{parentName:"ul",className:"task-list-item"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("input",{parentName:"p",type:"checkbox",checked:!1,disabled:!0})," ","Implement cancelling in the Packit API (knowing what needs to be\ncancelled, i.e., Copr build ID, Testing Farm request, etc.)")),(0,i.yg)("li",{parentName:"ul",className:"task-list-item"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("input",{parentName:"p",type:"checkbox",checked:!1,disabled:!0})," ","Implement methods that would yield respective jobs to be cancelled, i.e.,\nafter retriggering a Copr build, we should get a list of running Copr\nbuilds associated with the previous trigger")),(0,i.yg)("li",{parentName:"ul",className:"task-list-item"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("input",{parentName:"p",type:"checkbox",checked:!1,disabled:!0})," ","Automatically cancel running jobs once an update happens, e.g., push to\na PR, branch, or retriggering via comment.")),(0,i.yg)("li",{parentName:"ul",className:"task-list-item"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("input",{parentName:"p",type:"checkbox",checked:!1,disabled:!0})," ","Improve the previous method by incorporating subsequent jobs"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"NOTE"),": this might get more complex after implementation of job dependencies"))),(0,i.yg)("li",{parentName:"ul",className:"task-list-item"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("input",{parentName:"p",type:"checkbox",checked:!1,disabled:!0})," ","Allow users to cancel running jobs via comment")),(0,i.yg)("li",{parentName:"ul",className:"task-list-item"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("input",{parentName:"p",type:"checkbox",checked:!1,disabled:!0})," ","Allow users to cancel running jobs via custom GitHub Check ",(0,i.yg)("em",{parentName:"p"},"action")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"NOTE"),": custom action can incorporate additional metadata provided by us,\ntherefore cancelling this way could be pretty cheap (there would be no need\nto deduce which jobs need to be cancelled)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"NOTE"),": there's a smallish issue of differentiating of what should be\ncancelled (could be handled by multiple custom actions), for example:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Copr build for specific target")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Copr build for all targets")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Copr build for all targets matching an identifier")))))),(0,i.yg)("li",{parentName:"ul",className:"task-list-item"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("input",{parentName:"p",type:"checkbox",checked:!1,disabled:!0})," ","(optionally, low-prio) Allow this to be configurable"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("em",{parentName:"p"},"use case"),": I want to be able to test multiple Copr builds, even if they\nwere triggered in a succession of pushes")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("em",{parentName:"p"},"NOTE"),": this use case could be more beneficial for running ",(0,i.yg)("em",{parentName:"p"},"commit")," events\nrather than PR, i.e."),(0,i.yg)("blockquote",{parentName:"li"},(0,i.yg)("p",{parentName:"blockquote"},"as a maintainer I'd like to retain ",(0,i.yg)("strong",{parentName:"p"},"all")," builds\nthat were pushed to the ",(0,i.yg)("inlineCode",{parentName:"p"},"main"),", or ",(0,i.yg)("inlineCode",{parentName:"p"},"stable"))))))))}u.isMDXComponent=!0}}]);